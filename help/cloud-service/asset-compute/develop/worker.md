---
title: 開發資產計算員工
description: 資產計算工作者是資產計算項目的核心，因為它提供了對資產執行或協調的定製功能，以建立新的轉譯。
feature: asset-compute
topics: renditions, development
version: cloud-service
activity: develop
audience: developer
doc-type: tutorial
kt: 6282
thumbnail: KT-6282.jpg
translation-type: tm+mt
source-git-commit: af610f338be4878999e0e9812f1d2a57065d1829
workflow-type: tm+mt
source-wordcount: '1508'
ht-degree: 0%

---


# 開發資產計算員工

資產計算工作者是資產計算項目的核心，因為它提供了對資產執行或協調的定製功能，以建立新的轉譯。

「資產計算」項目會自動生成一個簡單工作器，該工作器將資產的原始二進位檔案複製到命名格式副本中，而不進行任何轉換。 在本教程中，我們將修改此工作器，以製作更有趣的轉譯，以說明「資產計算」工作器的強大功能。

我們將建立一個「資產計算」工作器，生成新的水準影像格式副本，該格式副本在資產格式副本的左側和右側覆蓋空白空間，並且資產版本模糊。 最終轉譯的寬度、高度和模糊都會參數化。

## 資產計算工作器調用的邏輯流

資產計算工作者在功能中實作資產計算SDK工作者API合 `renditionCallback(...)` 約，該合約在概念上：

+ __輸入：__ AEM資產的原始資產二進位檔和參數
+ __輸出：__ 要新增至AEM資產的一或多個轉譯

![資產計算工作器邏輯流](./assets/worker/logical-flow.png)

1. 當從AEM Author服務呼叫資產計算工作者時，它會透過「處理設定檔」針對AEM資產。 資產的 __(1a)__ （原始二進位檔）會透過轉譯回呼函式的參數傳遞給工作者， `source` (1b) __「處理設定檔」中透過參數集定義的任何__`rendition.instructions` 參數。
1. 資產計算SDK層接受處理配置檔案中的請求，並協調自定義資產計算工作者的功能的執行 `renditionCallback(...)` ，根據 __(1b)______ (1a)提供的任何參數轉換(1a)中提供的源二進位檔案，以生成源二進位檔案的格式副本。
   + 在本教學課程中，會建立「正在處理中」的轉譯，這表示工作者會合成轉譯，不過，來源二進位檔也可以傳送至其他Web服務API，以產生轉譯。
1. 「資產計算」工作者會儲存轉譯的二進位表示 `rendition.path` 法，以便儲存至AEM Author服務。
1. 完成時，寫入的二進位資 `rendition.path` 料會透過Asset Compute SDK傳輸，並透過AEM Author Service公開為AEM UI中的轉譯。

上圖說明了資產計算開發人員關注的問題和資產計算工作者調用的邏輯流程。 出於好奇，「資 [產計算」執行的內部詳細資訊可供使用](https://docs.adobe.com/content/help/en/asset-compute/using/extend/custom-application-internals.html) ，但只有公開的「資產計算SDK API」合約才應依賴。

## 工人解剖

所有資產計算員工都遵循相同的基本結構和輸入／輸出合同。

```javascript
'use strict';

// Any npm module imports used by the worker
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

/**
Exports the worker implemented by a custom rendition callback function, which parametrizes the input/output contract for the worker.
 + `source` represents the asset's original binary used as the input for the worker.
 + `rendition` represents the worker's output, which is the creation of a new asset rendition.
 + `params` are optional parameters, which map to additional key/value pairs, including a sub `auth` object that contains Adobe I/O access credentials.
**/
exports.main = worker(async (source, rendition, params) => {
    // Perform any necessary source (input) checks
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        // Throw appropriate errors whenever an erring condition is met
        throw new SourceCorruptError('source file is empty');
    }

    // Access any custom parameters provided via the Processing Profile configuration
    let param1 = rendition.instructions.exampleParam;

    /** 
    Perform all work needed to transform the source into the rendition.
    
    The source data can be accessed:
        + In the worker via a file available at `source.path`
        + Or via a presigned GET URL at `source.url`
    **/
    if (success) {
        // A successful worker must write some data back to `renditions.path`. 
        // This example performs a trivial 1:1 copy of the source binary to the rendition
        await fs.copyFile(source.path, rendition.path);
    } else {
        // Upon failure an Asset Compute Error (exported by @adobe/asset-compute-commons) should be thrown.
        throw new GenericError("An error occurred!", "example-worker");
    }
});

/**
Optionally create helper classes or functions the worker's rendition callback function invokes to help organize code.

Code shared across workers, or to complex to be managed in a single file, can be broken out across supporting JavaScript files in the project and imported normally into the worker. 
**/
function customHelperFunctions() { ... }
```

## 開啟工作器index.js

![自動產生的index.js](./assets/worker/autogenerated-index-js.png)

1. 確保資產計算項目在VS代碼中開啟
1. 導覽至資料 `/actions/worker` 夾
1. 開啟檔 `index.js` 案

這是我們在本教程中將修改的工作JavaScript檔案。

## 安裝和導入支援NPM模組

資產計算項目基於Node.js，可從強大的 [npm模組生態系統中獲益](https://npmjs.com)。 要利用npm模組，我們必須首先將它們安裝到Asset Compute項目中。

在此員工中，我們運用 [jimp](https://www.npmjs.com/package/jimp) ，直接在Node.js程式碼中建立和控制轉譯影像。

>[!WARNING]
>
>資產計算並非所有用於資產操縱的npm模組都受到支援。 npm模組依賴於其他應用程式（如ImageMagick或OS相關庫）的現有應用程式。 最好限制僅限JavaScriptnpm模組的使用。

1. 在「資產計算」項目的根目錄中開啟命令行(可以在「VS代碼」中通過「終端機>新 __終端機__」執行)並執行命令：

   ```
   $ npm install jimp
   ```

1. 將模 `jimp` 塊導入工作代碼中，以便通過 `Jimp` JavaScript對象使用。
更新 `require` 工作器頂部的指令，以 `index.js` 從模 `Jimp` 塊導入對 `jimp` 像：

   ```javascript
   'use strict';
   
   const { Jimp } = require('jimp');
   const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
   const fs = require('fs').promises;
   
   exports.main = worker(async (source, rendition, params) => {
       // Check handle a corrupt input source
       const stats = await fs.stat(source.path);
       if (stats.size === 0) {
           throw new SourceCorruptError('source file is empty');
       }
   
       // Do work here
   });
   ```

## 讀取參數

資產計算工作者可以讀取參數，這些參數可以透過在AEM中定義為雲端服務作者服務的處理設定檔傳入。 參數通過對象傳遞到工 `rendition.instructions` 作器。

通過訪問工作程式碼 `rendition.instructions.<parameterName>` 可以讀取這些代碼。

我們會在此讀取可設定轉譯的 `SIZE`, `BRIGHTNESS` 並 `CONTRAST`提供預設值（如果未透過處理設定檔提供）。 請注意， `renditions.instructions` 從AEM呼叫為「雲端服務處理設定檔」時，會以字串形式傳入，因此請確定這些設定檔已轉換為工作程式碼中的正確資料類型。

```javascript
'use strict';

const { Jimp } = require('jimp');
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    // Processing Profiles pass in instructions as Strings, so make sure to parse to correct data types
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    // Do work here
}
```

## 擲出錯誤{#errors}

資產計算工作者可能會遇到導致錯誤的情況。 Adobe Asset Compute SDK提供一 [套預先定義的錯誤](https://github.com/adobe/asset-compute-commons#asset-compute-errors) ，當遇到此類情況時可能會拋出這些錯誤。 如果未套用特定錯誤類型，則 `GenericError` 可使用，或可定義特 `ClientErrors` 定自訂。

在開始處理轉譯之前，請檢查以確保所有參數在此工作器的上下文中都有效且受支援：

+ 確保、和的轉 `SIZE`譯指 `CONTRAST`令參 `BRIGHTNESS` 數有效。 如果沒有，請擲回自訂錯誤 `RenditionInstructionsError`。
   + 此文 `RenditionInstructionsError` 件底部定 `ClientError` 義了擴展的自定義類。 在為工作者編寫測試時，使用特定的自 [訂錯誤](../test-debug/test.md) 很有用。

```javascript
'use strict';

const { Jimp } = require('jimp');
// Import the Asset Compute SDK provided `ClientError` 
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        // Ensure size is within allowable bounds
        throw new RenditionInstructionsError("'size' must be between 10 and 1,0000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Do work here
}

// Create a new ClientError to handle invalid rendition.instructions values
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        // Provide a:
        // + message: describing the nature of this erring condition
        // + name: the name of the error; usually same as class name
        // + reason: a short, searchable, unique error token that identifies this error
        super(message, "RenditionInstructionsError", "rendition_instructions_error");

        // Capture the strack trace
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## 建立轉譯

在讀取、淨化和驗證參數後，會編寫程式碼以產生轉譯。 產生轉譯的虛擬碼如下：

1. 以透過參 `renditionImage` 數指定的平方尺寸建立新畫 `size` 布。
1. 從來源 `image` 資產的二進位檔建立物件
1. 使用 __Jimp__ 程式庫來轉換影像：
   + 將原始影像裁切為置中的正方形
   + 從「平方」影像的中央剪下圓
   + 縮放以配合由參數值定義的 `SIZE` 尺寸
   + 根據參數值調整 `CONTRAST` 對比
   + 根據參數值調整 `BRIGHTNESS` 亮度
1. 將已轉換 `image` 的影像放入具有透 `renditionImage` 明背景的中心
1. 撰寫合成影片， `renditionImage` 以 `rendition.path` 便將它儲存回AEM做為資產轉譯。

此程式碼採用 [Jimp API](https://github.com/oliver-moran/jimp#jimp) ，以執行這些影像轉換。

資產計算工作者必須同步完成工作， `rendition.path` 並且必須在工作者完成之前完全寫回 `renditionCallback` 到。 這要求使用運算子同步進行非同步函式 `await` 呼叫。 如果您不熟悉JavaScript非同步函式，以及如何讓它們以同步方式執行，請熟悉 [JavaScript的等待運算子](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)。

完成的工 `index.js` 作者應如下：

```javascript
'use strict';

const Jimp = require('jimp');
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        throw new RenditionInstructionsError("'size' must be between 10 and 10,000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Create target rendition image of the target size with a transparent background (0x0)
    let renditionImage =  new Jimp(SIZE, SIZE, 0x0);

    // Read and perform transformations on the source binary image
    let image = await Jimp.read(source.path);

    // Crop a circle from the source asset, and then apply contrast and brightness using Jimp
    image.crop(
            image.bitmap.width < image.bitmap.height ? 0 : (image.bitmap.width - image.bitmap.height) / 2,
            image.bitmap.width < image.bitmap.height ? (image.bitmap.height - image.bitmap.width) / 2 : 0,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height
        )   
        .circle()
        .scaleToFit(SIZE, SIZE)
        .contrast(CONTRAST)
        .brightness(BRIGHTNESS);

    // Place the transformed image onto the transparent renditionImage to save as PNG
    renditionImage.composite(image, 0, 0)

    // Write the final transformed image to the asset's rendition
    renditionImage.write(rendition.path);
});

// Custom error used for renditions.instructions parameter checking
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        super(message, "RenditionInstructionsError", "rendition_instructions_error");
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## 運行工作器

現在工作程式碼已完成，而且先前已在 [manifest.yml中註冊並設定](./manifest.md)，您可使用本機資產計算開發工具來執行它，以檢視結果。

1. 從資產計算項目的根目錄
1. 執行 `app aio run`
1. 等待資產計算開發工具在新窗口中開啟
1. 在「選 __擇檔案……」中__ 下拉式清單中，選取要處理的範例影像
   + 選取範例影像檔案，做為來源資產二進位檔
   + 如果尚未出現任何影像，請點 __選左側的(+)__ ，並上傳範例影 [像檔案](../assets/samples/sample-file.jpg) ，然後重新整理「開發工具」瀏覽器視窗
1. 更新 `"name": "rendition.png"` 為此工作器，以產生透明PNG。
   + 請注意，此&quot;name&quot;參數僅用於開發工具，不應依賴。

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png"
           }
       ]
   }
   ```
1. 點選「 __執行__ 」，然後等待轉譯產生
1. 「轉 __譯__ 」區段會預覽產生的轉譯。 點選轉譯預覽以下載完整的轉譯

   ![預設PNG轉譯](./assets/worker/default-rendition.png)

### 使用參數運行工作器

透過「處理描述檔」設定傳入的參數，可在「資產計算開發工具」中模擬，方法是在轉譯參數JSON上提供它們作為索引鍵／值配對。

>[!WARNING]
>
>在本端開發期間，當從AEM以Cloud Service Processing Profiles以字串形式傳入時，可以使用各種資料類型傳入值，因此請務必分析正確的資料類型。
> 例如，Jimp的函 `crop(width, height)` 數要求其參數 `int`為&#39;。如果 `parseInt(rendition.instructions.size)` 未對int進行解析，則對的調用將失敗，因 `jimp.crop(SIZE, SIZE)` 為參數將不相容「字串」類型。

我們的程式碼接受下列參數：

+ `size` 定義轉譯的大小（高度和寬度為整數）
+ `contrast` 定義對比度調整，必須介於-1和1之間，作為浮標
+ `brightness`  定義亮調整，必須介於-1和1之間，作為浮動

這些內容在員工中通過以下方式 `index.js` 讀取：

+ `const SIZE = parseInt(rendition.instructions.size) || 800`
+ `const CONTRAST = parseFloat(rendition.instructions.contrast) || 0`
+ `const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0`

1. 更新轉譯參數以自訂大小、對比和亮度。

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png",
               "size": "450",
               "contrast": "0.30",
               "brightness": "0.15"
           }
       ]
   }
   ```

1. 再次點 __選「執行__ 」
1. 點選轉譯預覽以下載並檢視產生的轉譯。 請注意其尺寸，以及對比度和亮度與預設轉譯的變更方式。

   ![參數化PNG轉譯](./assets/worker/parameterized-rendition.png)

1. 將其他影像上傳至 __Source檔案下拉式清單__ ，然後嘗試使用不同的參數來針對工作者執行工作！

## Github上的Worker index.js

Github上 `index.js` 提供最終版本：

+ [aem-guides-wknd-asset-compute/actions/worker/index.js](https://github.com/adobe/aem-guides-wknd-asset-compute/blob/master/actions/worker/index.js)

## 疑難排解

### 傳回部分繪製的轉譯

+ __錯誤__:當轉譯檔案總大小較大時，轉譯會呈現不完整

   ![疑難排解——傳回的轉譯部分繪製](./assets/worker/troubleshooting__await.png)

+ __原因__:工作者的功 `renditionCallback` 能會在轉譯完全寫入之前退出 `rendition.path`。
+ __解析度__:檢閱自訂工作程式碼，並確保所有非同步呼叫都同步進行。
