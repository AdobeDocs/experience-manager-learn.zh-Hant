---
title: 開發Asset compute工
description: asset compute工作程式是Asset compute項目的核心，因為它提供了對資產執行或協調的自定義功能，以建立新格式副本。
feature: Asset Compute Microservices
topics: renditions, development
version: Cloud Service
activity: develop
audience: developer
doc-type: tutorial
kt: 6282
thumbnail: KT-6282.jpg
topic: Integrations, Development
role: Developer
level: Intermediate, Experienced
exl-id: 7d51ec77-c785-4b89-b717-ff9060d8bda7
source-git-commit: b069d958bbcc40c0079e87d342db6c5e53055bc7
workflow-type: tm+mt
source-wordcount: '1416'
ht-degree: 0%

---

# 開發Asset compute工

asset compute工作程式是Asset compute項目的核心，因為它提供了對資產執行或協調的自定義功能，以建立新格式副本。

asset compute項目將自動生成一個簡單工作程式，該工作程式將資產的原始二進位檔案複製到命名格式副本中，而不進行任何轉換。 在本教程中，我們將修改此工作人員，以進行更有趣的格式表示，以說明Asset compute工作人員的力量。

我們將建立一個Asset compute工作人員，該工作人員將生成一個新的水準影像格式副本，該格式副本將資產格式副本的左側和右側的空白區域與資產版本模糊的區域覆蓋。 最終格式副本的寬度、高度和模糊都是參數化的。

## asset compute工作器調用的邏輯流

asset compute工作程式執行Asset computeSDK工作程式API合同，在 `renditionCallback(...)` 函式，即概念上：

+ __輸入：__ 資產AEM的原始二進位和處理配置檔案參數
+ __輸出：__ 一個或多個要添加到資產的格AEM式副本

![asset compute工作流邏輯流](./assets/worker/logical-flow.png)

1. AEM作者服務調用Asset compute工作人員，提供資產 __(1a)__ 原始二進位檔案`source` 參數)和 __(1b)__ 在「處理配置檔案」中定義的任何參數(`rendition.instructions` )。
1. asset computeSDK協調自定義Asset compute元資料工作程式的執行 `renditionCallback(...)` 函式，根據資產的原始二進位格式副本生成新的二進位格式副本 __(1a)__ 和任何參數 __(1b)__。

   + 在本教程中，格式副本將建立為「正在進行」，這意味著工作程式會編寫格式副本，但源二進位檔案也可以發送到其他Web服務API以生成格式副本。

1. asset compute工作人員將新格式副本的二進位資料保存到 `rendition.path`。
1. 寫入的二進位資料 `rendition.path` 通過Asset computeSDK傳輸到AEM作者服務，並顯示為 __(4a)__ 文本格式副本和 __(4b)__ 永續到資產的元資料節點。

上圖闡述了面向Asset compute開發人員的關注點和Asset compute工作人員調用的邏輯流。 對於好奇的人， [執行Asset compute的內部詳細資訊](https://experienceleague.adobe.com/docs/asset-compute/using/extend/custom-application-internals.html) 可用，但只能依賴公共Asset computeSDK API合同。

## 工人解剖

所有Asset compute工人遵循相同的基本結構和投入/產出合同。

```javascript
'use strict';

// Any npm module imports used by the worker
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

/**
Exports the worker implemented by a custom rendition callback function, which parametrizes the input/output contract for the worker.
 + `source` represents the asset's original binary used as the input for the worker.
 + `rendition` represents the worker's output, which is the creation of a new asset rendition.
 + `params` are optional parameters, which map to additional key/value pairs, including a sub `auth` object that contains Adobe I/O access credentials.
**/
exports.main = worker(async (source, rendition, params) => {
    // Perform any necessary source (input) checks
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        // Throw appropriate errors whenever an erring condition is met
        throw new SourceCorruptError('source file is empty');
    }

    // Access any custom parameters provided via the Processing Profile configuration
    let param1 = rendition.instructions.exampleParam;

    /** 
    Perform all work needed to transform the source into the rendition.
    
    The source data can be accessed:
        + In the worker via a file available at `source.path`
        + Or via a presigned GET URL at `source.url`
    **/
    if (success) {
        // A successful worker must write some data back to `renditions.path`. 
        // This example performs a trivial 1:1 copy of the source binary to the rendition
        await fs.copyFile(source.path, rendition.path);
    } else {
        // Upon failure an Asset Compute Error (exported by @adobe/asset-compute-commons) should be thrown.
        throw new GenericError("An error occurred!", "example-worker");
    }
});

/**
Optionally create helper classes or functions the worker's rendition callback function invokes to help organize code.

Code shared across workers, or to complex to be managed in a single file, can be broken out across supporting JavaScript files in the project and imported normally into the worker. 
**/
function customHelperFunctions() { ... }
```

## 開啟工作器index.js

![自動生成的index.js](./assets/worker/autogenerated-index-js.png)

1. 確保Asset compute項目在VS代碼中開啟
1. 導航到 `/actions/worker` 資料夾
1. 開啟 `index.js` 檔案

這是我們在本教程中將修改的工作JavaScript檔案。

## 安裝和導入支援npm模組

基於Node.js的Asset compute項目得益於強健的 [npm模組生態系統](https://npmjs.com)。 要利用npm模組，我們必須首先將它們安裝到我們的Asset compute項目中。

在這個員工中，我們利用 [吉米](https://www.npmjs.com/package/jimp) 直接在Node.js代碼中建立和操作格式副本影像。

>[!WARNING]
>
>並非所有用於資產操作的npm模組都受Asset compute支援。 不支援依賴ImageMagick或其他OS相關庫等應用程式存在的npm模組。 最好限制只使用JavaScriptnpm模組。

1. 在Asset compute項目的根目錄中開啟命令行(可以在VS代碼中通過 __終端>新終端__)並執行命令：

   ```
   $ npm install jimp
   ```

1. 導入 `jimp` 模組到工作代碼中，以便通過 `Jimp` JavaScript對象。
更新 `require` 在工人的 `index.js` 導入 `Jimp` 對象 `jimp` 模組：

   ```javascript
   'use strict';
   
   const Jimp = require('jimp');
   const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
   const fs = require('fs').promises;
   
   exports.main = worker(async (source, rendition, params) => {
       // Check handle a corrupt input source
       const stats = await fs.stat(source.path);
       if (stats.size === 0) {
           throw new SourceCorruptError('source file is empty');
       }
   
       // Do work here
   });
   ```

## 讀取參數

asset compute工作人員可以讀取參數，這些參數可以通過as a Cloud Service作者服務中定義的「處理配置AEM檔案」傳遞。 參數通過 `rendition.instructions` 的雙曲餘切值。

可通過訪問 `rendition.instructions.<parameterName>` 的下界。

在此，我們將閱讀可配置格式副本的 `SIZE`。 `BRIGHTNESS` 和 `CONTRAST`，如果未通過「處理配置檔案」提供預設值，則提供預設值。 請注意 `renditions.instructions` 在從as a Cloud Service處理配置式調用時AEM，將作為字串傳入，因此請確保將它們轉換為工作代碼中的正確資料類型。

```javascript
'use strict';

const Jimp = require('jimp');
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    // Processing Profiles pass in instructions as Strings, so make sure to parse to correct data types
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    // Do work here
}
```

## 引發錯誤{#errors}

asset compute工作人員可能遇到導致錯誤的情況。 AdobeAsset computeSDK提供 [一組預定義的錯誤](https://github.com/adobe/asset-compute-commons#asset-compute-errors) 當遇到此類情況時可拋出。 如果不應用特定錯誤類型， `GenericError` 可以使用，或特定自定義 `ClientErrors` 可以定義。

在開始處理格式副本之前，請檢查以確保所有參數在此工作人員的上下文中均有效且受支援：

+ 確保格式副本指令參數 `SIZE`。 `CONTRAST`, `BRIGHTNESS` 有效。 否則，引發自定義錯誤 `RenditionInstructionsError`。
   + 自定義 `RenditionInstructionsError` 類擴展 `ClientError` 在此檔案的底部定義。 使用特定的自定義錯誤在 [寫test](../test-debug/test.md) 為工人準備的。

```javascript
'use strict';

const Jimp = require('jimp');
// Import the Asset Compute SDK provided `ClientError` 
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        // Ensure size is within allowable bounds
        throw new RenditionInstructionsError("'size' must be between 10 and 1,0000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Do work here
}

// Create a new ClientError to handle invalid rendition.instructions values
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        // Provide a:
        // + message: describing the nature of this erring condition
        // + name: the name of the error; usually same as class name
        // + reason: a short, searchable, unique error token that identifies this error
        super(message, "RenditionInstructionsError", "rendition_instructions_error");

        // Capture the strack trace
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## 建立格式副本

通過讀取、清理和驗證這些參數，將編寫代碼以生成格式副本。 格式副本生成的虛擬碼如下所示：

1. 新建 `renditionImage` 通過 `size` 的下界。
1. 建立 `image` 源資產的二進位對象
1. 使用 __金普__ 轉換影像的庫：
   + 將原始影像裁剪到居中的方形
   + 從「方形」影像的中心剪切圓
   + 縮放以適合由 `SIZE` 參數值
   + 根據 `CONTRAST` 參數值
   + 根據 `BRIGHTNESS` 參數值
1. 將轉型的 `image` 進入中心 `renditionImage` 具有透明背景
1. 寫作， `renditionImage` 至 `rendition.path` 這樣它就能以資產格AEM式副本的形式存回。

此代碼使用 [Jimp API](https://github.com/oliver-moran/jimp#jimp) 執行這些影像轉換。

asset compute工人必須同步完成工作， `rendition.path` 必須在工人的 `renditionCallback` 完成。 這要求使用 `await` 運算子。 如果您不熟悉JavaScript非同步函式以及如何使其以同步方式執行，請熟悉 [JavaScript的等待運算子](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)。

已完成的工作人員 `index.js` 應該是這樣的：

```javascript
'use strict';

const Jimp = require('jimp');
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read/parse and validate parameters
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        throw new RenditionInstructionsError("'size' must be between 10 and 1,0000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Create target rendition image 
    let renditionImage =  new Jimp(SIZE, SIZE, 0x0);

    // Read and perform transformations on the source binary image
    let image = await Jimp.read(source.path);

    // Crop a circle from the source asset, and then apply contrast and brightness
    image.crop(
            image.bitmap.width < image.bitmap.height ? 0 : (image.bitmap.width - image.bitmap.height) / 2,
            image.bitmap.width < image.bitmap.height ? (image.bitmap.height - image.bitmap.width) / 2 : 0,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height
        )   
        .circle()
        .scaleToFit(SIZE, SIZE)
        .contrast(CONTRAST)
        .brightness(BRIGHTNESS);

    // Place the transformed image onto the transparent renditionImage to save as PNG
    renditionImage.composite(image, 0, 0)

    // Write the final transformed image to the asset's rendition
    await renditionImage.writeAsync(rendition.path);
});

// Custom error used for renditions.instructions parameter checking
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        super(message, "RenditionInstructionsError", "rendition_instructions_error");
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## 運行工作進程

現在工作代碼已完成，並且以前已在 [manifest.yml](./manifest.md)，可以使用本地Asset compute開發工具執行，以查看結果。

1. 從Asset compute項目的根
1. 執行 `aio app run`
1. 等待Asset compute開發工具在新窗口中開啟
1. 在 __選擇檔案……__ 下拉，選擇要處理的示例影像
   + 選擇要用作源資產二進位檔案的示例影像檔案
   + 如果尚不存在，請點擊 __(+)__ 向左，並上傳 [樣本影像](../assets/samples/sample-file.jpg) 檔案，並刷新「開發工具」瀏覽器窗口
1. 更新 `"name": "rendition.png"` 作為此工作程式生成透明PNG。
   + 請注意，此&quot;name&quot;參數僅用於開發工具，不應依賴。

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png"
           }
       ]
   }
   ```

1. 點擊 __運行__ 等待格式副本生成
1. 的 __格式副本__ 節預覽生成的格式副本。 點擊格式副本預覽以下載完整格式副本

   ![預設PNG格式副本](./assets/worker/default-rendition.png)

### 使用參數運行工作程式

通過「處理配置檔案」配置傳入的參數可以在「Asset compute開發工具」中模擬，方法是在格式副本參數JSON上將它們作為鍵/值對提供。

>[!WARNING]
>
>在本地開發期間，當將值作為字串從「Cloud Service處理配置檔案」作為字串傳入時，可以使用各種資料類型傳入，AEM因此確保在需要時分析正確的資料類型。
> 比如，金普 `crop(width, height)` 函式要求其參數 `int`S如果 `parseInt(rendition.instructions.size)` 未解析為int，則調用 `jimp.crop(SIZE, SIZE)` 失敗，因為參數的「String」類型不相容。

我們的代碼接受以下參數：

+ `size` 定義格式副本的大小（高度和寬度為整數）
+ `contrast` 定義對比度調整，必須介於–1和1之間，作為浮標
+ `brightness`  定義亮調整，必須介於–1和1之間，作為浮標

這些是在工作人員中讀取的 `index.js` 通過：

+ `const SIZE = parseInt(rendition.instructions.size) || 800`
+ `const CONTRAST = parseFloat(rendition.instructions.contrast) || 0`
+ `const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0`

1. 更新格式副本參數以自定義大小、對比度和亮度。

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png",
               "size": "450",
               "contrast": "0.30",
               "brightness": "0.15"
           }
       ]
   }
   ```

1. 點擊 __運行__ 再次
1. 按一下格式副本預覽以下載並查看生成的格式副本。 請注意其尺寸以及對比度和亮度與預設格式副本相比的更改方式。

   ![參數化PNG格式副本](./assets/worker/parameterized-rendition.png)

1. 將其他影像上載到 __源檔案__ 下拉，然後嘗試使用不同的參數運行工作程式！

## Github上的Worker index.js

決賽 `index.js` 在Github上提供，網址為：

+ [aem-guides-wknd-asset-compute/actions/worker/index.js](https://github.com/adobe/aem-guides-wknd-asset-compute/blob/master/actions/worker/index.js)

## 疑難排解

+ [返回的格式副本部分已繪製/損壞](../troubleshooting.md#rendition-returned-partially-drawn-or-corrupt)
