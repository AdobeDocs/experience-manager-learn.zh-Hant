---
title: 第3章——高級快取主題
seo-title: Dispatcher AEM Cache Demystified —— 第3章——高級快取主題
description: Dispatcher Cache解AEM析教程的第3章介紹了如何克服第2章中討論的限制。
seo-description: Dispatcher Cache解AEM析教程的第3章介紹了如何克服第2章中討論的限制。
translation-type: tm+mt
source-git-commit: b040bdf97df39c45f175288608e965e5f0214703
workflow-type: tm+mt
source-wordcount: '6187'
ht-degree: 0%

---


# 第3章——高級快取主題

*「在電腦科學中，只有兩件難事：快取失效和命名項目。」*

— 菲爾·卡爾頓

## 概覽

這是三個部分的第3部分——系列以快取AEM。 前兩個部分著重於Dispatcher中的純http快取，以及存在哪些限制。 本部分討論如何克服這些限制。

## 一般快取

[本系](chapter-1.md) 列的 [第](chapter-2.md) 1章和第2章主要針對Dispatcher。我們已說明您必須取捨的基本功能、限制以及所需的地方。

快取複雜性和複雜性並非Dispatcher所獨有的問題。 一般而言，快取很困難。

讓Dispatcher做為工具箱中唯一的工具，實際上是個限制。

在本章中，我們希望進一步擴展我們對快取的看法，並開發一些有關如何克服Dispatcher的一些缺點的想法。 沒有萬靈丹——您必須在專案中權衡取捨。 請記住，隨著快取和失效精確度的提高，總是會產生複雜性，而且隨著複雜性的增加，可能會產生錯誤。

你需要在這些領域做出權衡，

* 效能與延遲
* 資源消耗/CPU負載／磁碟使用
* 準確性／貨幣／陳舊性／安全性
* 簡單性／複雜性／成本／可維護性／易出錯性

這些維度在一個相當複雜的系統中相互關聯。 沒有簡單的，如果。.。 讓系統更簡單可讓系統更快速或更慢。 它可以降低您的開發成本，但會增加服務台的成本，例如，如果客戶看到過時的內容或抱怨網站速度緩慢。 所有這些因素都需要相互考慮和平衡。 但到現在，你應該有一個好主意，那就是沒有萬靈丹，也沒有一個「最佳實踐」—只有許多壞做法和一些好做法。

## 連結快取

### 概覽

#### 資料流

將頁面從伺服器傳送至用戶端的瀏覽器，會跨越多個系統和子系統。 如果仔細查看，需要從源到漏的資料中提取許多跳數，每個跳數都是快取的潛在候選。

![典型CMS應用程式的資料流](assets/chapter-3/data-flow-typical-cms-app.png)

*典型CMS應用程式的資料流*

<br> 

讓我們從硬碟上需要在瀏覽器中顯示的資料開始我們的旅程。

#### 硬體與作業系統

首先，硬碟(HDD)本身在硬體中有內置的快取。 其次，裝載硬碟的作業系統使用空閒記憶體快取頻繁訪問的塊以加快訪問速度。

#### 內容儲存庫

下一級是CRX或Oak —— 由使用的檔案資料庫AEM。 CRX和Oak將資料分割為可在記憶體中快取的區段，以避免存取HDD的速度變慢。

#### 第三方資料

大部分的Web安裝都有第三方資料；來自產品資訊系統、客戶關係管理系統、舊式資料庫或任何其他任意web服務的資料。 不需要在任何需要時從來源提取此資料，尤其是在已知變更不太頻繁時。 因此，如果CRX資料庫中未同步，則可快取它。

#### 業務層——應用程式／型號

通常您的範本指令碼不會透過JCR API轉譯來自CRX的原始內容。 您最有可能在業務層之間合併、計算和／或轉換業務域對象中的資料。 猜猜怎麼著？如果這些操作成本很高，您應該考慮將它們快取。

#### 標籤片段

模型現在是繪製元件標籤的基礎。 為什麼不快取轉換的模型？

#### Dispatcher、CDN和其他Proxy

關閉會將轉譯的HTML-Page轉至Dispatcher。 我們已討論過，Dispatcher的主要用途是快取HTML頁面和其他Web資源（儘管其名稱為）。 在資源到達瀏覽器之前，它可能會傳遞反向proxy（可快取和CDN），此代理也會用來快取。 用戶端可能位於辦公室，僅透過代理授與Web存取權，而代理可能決定快取並儲存流量。

#### 瀏覽器快取

最後，瀏覽器也會快取。 這是一項容易忽視的資產。 但它是您在快取鏈中最接近、最快的快取。 遺憾的是，它不會在使用者之間共用，但仍會在使用者的不同要求之間共用。

### 快取位置及原因

這是一長串潛在的快取。 我們都面臨過一些問題：我們看到過時的內容。 但是，考慮到它有多少個階段，它大部分時間都在運作，這是個奇跡。

但是，在這條鍊子中，快取有什麼意義呢？ 一開始呢？ 最後？ 到處都是？ 這要看……它取決於很多因素。 即使是同一個網站中的兩個資源，也可能需要不同的答案。

為了讓您大致瞭解您可能考慮哪些因素，

**即時時間** -如果物件的固有即時時間較短（流量資料的即時時間可能比氣象資料短），則不值得快取。

**生產成** 本——對象的再生產和交付成本（就CPU週期和I/O而言）。如果是便宜的快取，可能就不必了。

**大小** -大型物件需要更多資源才能快取。這可能是一個限制因素，必須與利益相平衡。

**存取頻率** -如果物件很少存取，快取可能無效。它們只會過時或失效，才會從快取中第二次存取。 這些項目只會阻塞記憶體資源。

**共用存取** -多個實體使用的資料應在鏈上進一步快取。事實上，快取鏈不是鏈，而是樹。 儲存庫中的一條資料可能由多個模型使用。 這些模型可由多個演算指令碼來產生HTML片段。 這些片段包含在多個頁面中，這些頁面會在瀏覽器中以其私用快取傳送給多位使用者。 因此，「分享」並不只意味著在人與人之間分享，而是在軟體之間分享。 如果您想要尋找潛在的「共用」快取，只要追蹤樹狀結構回根目錄，並尋找共同的祖先，您就應該快取。

**地理空間分發** -如果您的使用者分散在全球各地，使用快取分散式網路可能有助於減少延遲。

**網路頻寬和延遲** -說到延遲，您的客戶是誰，他們使用的是何種網路？也許您的客戶是使用舊一代智慧型手機3G連線的發達國家的行動客戶？ 請考慮建立較小的物件，並在瀏覽器快取中快取這些物件。

這份清單目前還不完整，但我們認為您現在已經知道了。

### 連結快取的基本規則

同樣地，快取很困難。 讓我們分享一些基本規則，這些規則是我們從先前的專案中擷取的，可協助您避免專案中的問題。

#### 避免雙重快取

在最後一章中介紹的每一層都在快取鏈中提供了一些值。 您可以節省計算週期，也可以讓資料更貼近消費者。 在鏈的多個階段快取一段資料並不錯誤，但您應始終考慮下一階段的好處和成本。 在Publish系統中快取完整頁面通常不提供任何好處，這在Dispatcher中已經做到。

#### 混合失效策略

有三種基本的失效策略：

* **TTL，存留時間：** 物件在固定時間後過期（例如，「2小時後」）
* **過期日** 期：物件在定義的日後時間過期（例如「2019年6月10日下午5:00」）
* **基於事件：** 對象被平台中發生的事件（例如，當頁面被更改和激活時）明確失效

現在，您可以在不同的快取層上使用不同的策略，但有一些「有毒」的策略。

#### 事件型失效

![純事件型失效](assets/chapter-3/event-based-invalidation.png)

*純事件型失效：從內部快取到外部層無效*

<br> 

純粹基於事件的失效是最容易理解的失效，最容易在理論上得到正確的失效，也是最準確的失效。

簡單地說，在對象改變後，快取逐個失效。

您只需要記住一個規則：

始終使內部到外部快取無效。 如果先使外部快取失效，它可能會從內部快取中重新快取過時內容。 不要在快取何時重新更新時做出任何假設——請確定。 最好，通過在使內部快取無效後觸發外部快取的失效。__

這就是理論。 但實際上，存在許多疑問。 事件必須通過網路分發——可能。 在實踐中，這是最難實現的失效方案。

#### 自動——修復

在事件型失效時，您應有應急計畫。 如果遺失失效事件，該怎麼辦？ 一個簡單的策略是在一定時間後失效或清除。 因此——您可能錯過了該事件，現在會提供過時的內容。 但您的物件也只有數小時（天）的隱式TTL。 最終，系統自動修復。

#### 純基於TTL的失效

![基於未同步TTL的失效](assets/chapter-3/ttl-based-invalidation.png)

*基於未同步TTL的失效*

<br> 

這個方案也是相當普遍的。 您堆疊數層快取，每層快取都有權在一定時間內提供物件。

易於實施。 不幸的是，很難預測資料的有效壽命。

![延長內物體壽命的外殼](assets/chapter-3/outer-cache.png)

*延長內部對象壽命的外部快取*

<br> 

請考慮上圖。 每個快取層會引入2分鐘的TTL。 現在——總TTL也必須2分鐘，對吧？ 不是。 如果外層在過時之前提取對象，外層實際上延長了對象的有效生存時間。 在此情況下，有效的即時時間可在2到4分鐘之間。 考慮到您與業務部門達成了共識，有一天是可以忍受的，而且您有四層快取。 每個層上的實際TTL不得超過6小時……增加快取丟失率……

我們並不是說這是個壞計畫。 你應該知道它的局限性。 這是一個簡單好用的策略。 只有當網站流量增加時，您才會考慮更準確的策略。

*通過設定特定日期來同步失效時間*

#### 到期日型失效

如果您要在內部物件上設定特定日期並將其傳播至外部快取，則可獲得更可預測的有效生命期。

![同步到期日期](assets/chapter-3/synchronize-expiration-dates.png)

*同步到期日期*

<br> 

但是，並非所有快取都能傳播日期。 當外部快取聚合兩個具有不同到期日的內部對象時，這可能會變得令人討厭。

#### 基於事件和基於TTL的混合失效

![混合基於事件和基於TTL的策略](assets/chapter-3/mixing-event-ttl-strategies.png)

*混合基於事件和基於TTL的策略*

<br> 

此外，世AEM界上常見的方案是在內部快取（例如，記憶體內快取，可以在接近即時的情況下處理事件）和外部基於TTL的快取上使用基於事件的失效——在這些快取中，您可能沒有明確失效的訪問權限。

在世AEM界上，當基礎資源發生變更，而您將此變更事件傳播到調度程式，同時也基於事件工作時，Publish系統中的業務對象和HTML片段會有記憶體快取，該快取會失效。 在前面，您會有例如以TTL為基礎的CDN。

在Dispatcher前面放置一層（短）的基於TTL的快取，可以有效地緩和通常在自動失效後會發生的尖峰。

#### 混合TTL和基於事件的失效

![混合TTL和基於事件的失效](assets/chapter-3/toxic.png)

*有毒：混合TTL和基於事件的失效*

<br> 

這種組合是有毒的。 切勿在TTL或過期快取後置入和事件型快取。 還記得我們在「純TTL」策略中的溢出效應嗎？ 這裡可以觀察到相同的效果。 只有外部快取的失效事件已經發生，才不會再發生——這可以將快取對象的壽命擴展到無窮大。

![TTL和事件相結合：溢出至無窮無盡](assets/chapter-3/infinity.png)

*TTL和事件相結合：溢出至無窮無盡*

<br> 

## 部分快取和記憶體內快取

您可以勾選到轉換程式的階段，以新增快取圖層。 從取得遠端資料傳輸物件或建立本端商業物件，到快取單一元件的轉譯標籤。 我們將在稍後的教學課程中提供具體實作。 但是，您可能已打算自行建置其中一些快取層。 因此，我們至少可以在這裡介紹基本原則——以及疑問。

### 警告字詞

#### 尊重訪問控制

此處描述的技巧相當強大，而且每個開發人員的工具箱中都有&#x200B;_must-haveAEM_。 但別太激動，要明智地使用。 將物件儲存在快取中，並在後續請求中共用給其他使用者，實際上就是規避存取控制。 這通常不是公開網站的問題，但是當使用者需要先登入才能存取時，才會發生問題。

請考慮將網站主功能表的HTML標籤儲存在記憶體中快取中，以便在不同的頁面之間共用。 實際上，將部分轉譯的HTML儲存為建立導覽的最佳範例，通常很昂貴，因為它需要遍歷許多頁面。

您不會在所有頁面之間共用相同的功能表結構，而是會與所有使用者共用，讓它更有效率。 但等等……但功能表中可能有些項目僅保留給特定使用者群組。 在這種情況下，快取可能會變得更複雜。

#### 僅快取自定義業務對象

如果有的話——這是最重要的建議，我們可以給你：

>[!WARNING]
>
>只快取您自己構建、淺層且沒有外發引用的不可變的、屬於您的對象。

這是什麼意思？

1. 你不知道別人物品的預定生命週期。 請考慮您看到請求物件的參考，並決定快取它。 現在，請求已結束，Servlet容器要為下一個傳入請求循環使用該對象。 在這種情況下，其他人會變更您認為您擁有獨家控制權的內容。 不要忽視這一點——我們在一個項目中看到了類似的情況。 客戶看到的是其他客戶資料，而非他們自己的資料。

2. 只要對象被其它引用鏈引用引用，它就不能從堆中刪除。 如果您的快取中保留參照的小物件，假設影像有4MB的顯示，您就很有可能遇到記憶體外洩的問題。 快取應以弱參照為基礎。 但是——弱參照無法如預期般奏效。 這是產生記憶體洩漏並導致記憶體不足錯誤的絕對最佳方法。 而且，你不知道這些外來物體的記憶體大小，對吧？

3. 尤其是在Sling中，您可以（幾乎）將每個物件彼此調整。 考慮將資源放入快取中。 下一個請求（具有不同的訪問權限）將提取該資源並將其調整到resourceResolver或會話中，以訪問他無權訪問的其他資源。

4. 即使您在資源周圍建立精簡的「包裝函式」AEM，也不能快取該包裝函式——即使它是您自己的、不可變的。 包裝物件會是參照（我們之前禁止），如果我們看起來很清晰，就會產生與上一個項目中描述的相同問題。

5. 如果要快取，請將基本資料複製至您自己的Shallo物件，以建立您自己的物件。 您可能希望通過引用在自己的對象之間進行連結——例如，您可能希望快取對象樹。 這不錯，但只會快取您剛在相同請求中建立的物件，而不會從其他位置要求任何物件（即使是&#39;your&#39;物件的名稱空間）。 _複製_ 物件是金鑰。此外，請務必一次清除連結物件的整個結構，並避免對結構的傳入和傳出參照。

6. 是的——而且您的物件不可變。 私有屬性，僅限，無設定者。

這是很多規則，但值得遵循。 即使你經驗豐富，聰明絕頂，一切盡在掌控之中。 你項目中的年輕同事剛從大學畢業。 他不知道這些陷阱。 如果沒有陷阱，就沒什麼可避免的。 保持簡單易懂。

### 工具與資料庫

本系列內容是瞭解概念並讓您建立最符合使用案例的架構。

我們並未特別推廣任何工具。 但請給您提示如何評估它們。 例如，AEM自6.0版起，就有簡單的內建快取和固定的TTL。你要用嗎？ 在發佈中，事件型快取會跟隨在連結中(提示：Dispatcher)。 但對作者而言，這或許是一個不錯的選擇。 此外，AdobeACS共用的HTTP快取也值得考慮。

或者，您也可以根據[Ehcache](https://www.ehcache.org)等成熟的快取架構，建立自己的快取架構。 這可用於快取Java對象和渲染的標籤（`String`對象）。

在某些簡單的情況下，您也可能會使用並行雜湊地圖——您會在此快速看到限制——不論是在工具中，還是在您的技巧中。 並行授權與命名和快取一樣難以掌握。

#### 引用

* [ACS公域http快取  ](https://adobe-consulting-services.github.io/acs-aem-commons/features/http-cache/index.html)
* [Ehcache快取架構](https://www.ehcache.org)

### 基本詞語

我們不會太深入探討快取理論，但我們覺得必須提供一些熱門話題，讓您快速上手。

#### 快取逐出

我們討論過很多關於失效和清洗的問題。 _快取_ 驅逐與下列詞語相關：在條目被逐出後，它便不再可用。但驅逐不是在條目過期時，而是在快取已滿時。 較新或「較重要」的項目會將較舊或較不重要的項目從快取中推出。 您必須犧牲哪些條目是個案決定。 您可能想要驅逐最舊的、很少使用或長時間存取的。

#### 搶先快取

搶先快取意味著，當項目失效或認為已過時時，就會重新建立含有新內容的項目。 當然，您只需使用一些資源，即可立即頻繁訪問。 否則，您將浪費資源來建立可能從未被請求的快取條目。 通過搶先建立快取條目，可以減少快取失效後第一個請求對資源的延遲。

#### 快取預熱

快取預熱與搶佔式快取密切相關。 雖然您不會在即時系統中使用這個詞。 而且，與前者相比，它的時間限制更小。 失效後不會立即重新快取，但是在時間允許時，您會逐步填入快取。

例如，您從負載平衡器取出Publish / Dispatcher腿以進行更新。 在重新整合之前，您會自動搜尋最常存取的頁面，以再次將它們存入快取中。 當快取為「溫暖」時——已充滿，您就會將支腳重新整合至負載平衡器。

或者，你一次重新整合腿部，但是你將流量調節到該腿部，這樣它就有機會按常規使用來預熱它的快取。

或者，您也可以在系統閒置時，快取一些較不常存取的頁面，以減少實際請求存取的延遲。

#### 快取對象標識、裝載、失效相關性和TTL

一般而言，快取物件或「項目」有五大屬性，

#### 關鍵

這是您識別和物件的屬性。 要檢索其有效負載，或從快取中清除它。 例如，調度程式使用頁面的URL作為密鑰。 請注意，調度程式不使用頁路徑。 這不足以區分不同的表現。 其他快取可能使用不同的金鑰。 稍後我們將看到一些例子。

#### 值／裝載

這就是物體的寶庫，你要擷取的資料。 如果是調度程式，則是檔案內容。 但它也可以是Java對象樹。

#### TTL

我們已經涵蓋了TTL。 在此時間之後，某個條目被視為過時，不應再傳送。

#### 相依性

這與基於事件的失效有關。 該物件所依賴的原始資料為何？ 在第一部分，我們已經說過，真正和準確的依賴追蹤太複雜了。 但是，有了我們對系統的瞭解，您可以用更簡單的模型來近似依賴關係。 我們使足夠多的物件失效，以清除過時的內容……而且可能不慎超出所需的範圍。 然而，我們仍試圖保持「清除一切」的水準。

每個應用程式中哪些物件是依其他物件的正版而定。 我們稍後將提供一些如何實施依賴策略的示例。

### HTML片段快取

![在不同頁面上重新使用轉譯的片段](assets/chapter-3/re-using-rendered-fragment.png)

*在不同頁面上重新使用轉譯的片段*

<br> 

HTML片段快取是強大的工具。 其構想是快取記憶體內快取中，由元件產生的HTML標籤。 你可能會問，我為什麼要這麼做？ 我仍然會快取Dispatcher中整個頁面的標籤——包括該元件的標籤。 我們同意。 確實如此，但每頁只需一次。 您不會在頁面之間共用該標籤。

試想一下，您會在每個頁面的頂端轉換導覽。 每個頁面上的標籤看起來都相同。 但是，您會針對每個頁面（不在Dispatcher中）反複呈現它。 記住：自動失效後，所有頁面都需要重新轉譯。 所以基本上，您執行的程式碼和結果是相同的幾百次。

從我們的經驗來看，轉換巢狀頂端導覽是一項非常昂貴的工作。 通常，您會遍歷文檔樹的一大部分以生成導航項。 即使您只需要導覽標題和URL，頁面也必須載入記憶體中。 這裡，它們正在堵塞寶貴的資源。 一次又一次。

但元件會在許多頁面之間共用。 而分享是使用快取的指示。 所以——您要做的是檢查導覽元件是否已轉譯和快取，而不是重新轉譯，只會發出快取值。

這個計畫有兩個美妙的細節很容易遺漏：

1. 您正在快取Java字串。 字串沒有任何外發引用，並且是不可變的。 因此，考慮到上述警告，這是超級安全的。

2. 失效也非常容易。 每當網站發生任何變更時，您都希望使此快取項目無效。 重建相對便宜，因為它只需要執行一次，然後被所有數百個頁面重複使用。

這可讓您的「發佈」伺服器大放異彩。

### 片段快取的實作

#### 自訂標籤

在過去，您使用JSP做為範本引擎時，使用自訂JSP標籤來包住元件轉換程式碼是很常見的。

```
<!-- Pseudo Code -->

<myapp:cache
  key=' ${info.homePagePath} + ${component.path}'
  cache='main-navigation'
  dependency='${info.homePagePath}'>

… original components code ..

</myapp:cache>
```

自訂標籤會擷取其內文並將它寫入快取中，或防止執行其內文並輸出快取項目的裝載。

「金鑰」是它在首頁上的元件路徑。 我們不會在目前頁面上使用元件的路徑，因為這會為每個頁面建立一個快取項目——這與我們分享該元件的意圖相抵觸。 我們也不會只使用元件相對路徑(`jcr:conten/mainnavigation`)，因為這樣會阻止我們在不同網站中使用不同的導覽元件。

「快取」是儲存項目的指標。 您通常有多個快取，可將項目儲存在其中。 每一種可能會有些不同。 因此，區分所儲存的內容是件好事——即使最終只是串連。

「相依性」是快取項目所依賴的。 「主導覽」快取可能有規則，如果節點「相依性」下方有任何變更，則必須清除依據項目。 因此——您的快取實現將需要將自身註冊為儲存庫中的事件偵聽器，以便知道更改，然後應用快取特定規則以查找需要失效的內容。

以上只是一個例子。 您也可以選擇有快取樹。 當第一層用於分隔網站（或租戶），而第二層則分支為內容類型（例如「主導覽」）時——這可讓您省去新增首頁路徑的麻煩，如上例所示。

順便說一下，您也可以將此方法與更現代的HTL元件搭配使用。 然後，您的HTL指令碼會有JSP包裝函式。

#### 元件篩選

但是，在純HTL方法中，您寧可使用Sling元件篩選來建立片段快取。 我們尚未在野外看到這個，但我們在這個問題上會採取這樣的方式。

#### Sling Dynamic Include

如果您在變更的環境（不同頁面）中有常數（導覽），則會使用片段快取。

但您可能也會有相反的內容，即相對恆定的內容（很少變更的頁面），以及該頁面上一些不斷變更的片段（例如即時提示）。

在此例中，您可能會給[Sling Dynamic Includes](https://sling.apache.org/documentation/bundles/dynamic-includes.html)一次機會。 本質上，這是元件篩選，它會環繞動態元件，而不是將元件轉譯至其建立參照的頁面。 此參考可以是Ajax呼叫——如此瀏覽器便會包含此元件，因此可靜態快取周圍的頁面。 或者——或者- Sling Dynamic Include可產生SSI指令（伺服器端包含）。 此指令將在Apache伺服器中執行。 如果您使用支援ESI指令碼的清漆或CDN，您甚至可以使用ESI —— 邊緣端包含指令。

![使用Sling Dynamic Include之請求的序列圖](assets/chapter-3/sequence-diagram-sling-dynamic-include.png)

*使用Sling Dynamic Include之請求的序列圖*

<br> 

SDI檔案指出，您應停用以&quot;*.nocache.html&quot;結尾之URL的快取，這很合理，因為您正在處理動態元件。

您可能會看到另一個使用SDI的選項：如果&#x200B;_不_&#x200B;禁用包含的分發程式快取，則Dispatcher的作用類似於我們在最後一章中介紹的碎片快取：請求頁面時，頁面和元件片段會平等且獨立地快取在調度器中，並由Apache伺服器中的SSI指令碼拼接在一起。 若要這麼做，您可以實作共用元件，例如主導覽（若您總是使用相同的元件URL）。

理論上，這應該管用。 但是……

我們建議不要這樣做：您將無法略過實際動態元件的快取。 SDI是全局配置的，您對&quot;poor-mans-fragment-cache&quot;所做的更改也將應用於動態元件。

我們建議您仔細閱讀SDI檔案。 SDI還有其他一些限制，但在某些情況下，SDI是很有價值的工具。

#### 引用

* [docs.oracle.com —— 如何編寫自訂JSP標籤](https://docs.oracle.com/cd/E11035_01/wls100/taglib/quickstart.html)
* [Dominik Süß —— 建立和使用元件濾鏡](https://www.slideshare.net/connectwebex/prsentation-dominik-suess)
* [sling.apache.org - Sling Dynamic Includes](https://sling.apache.org/documentation/bundles/dynamic-includes.html)
* [helpx.adobe.com —— 設定Sling Dynamic Includes AEM in](https://helpx.adobe.com/experience-manager/kt/platform-repository/using/sling-dynamic-include-technical-video-setup.html)


#### 模型快取

![基於模型的快取：一個商業物件，包含兩種不同的轉譯](assets/chapter-3/model-based-caching.png)

*基於模型的快取：一個商業物件，包含兩種不同的轉譯*

<br> 

讓我們再次瀏覽此案例。 我們假設，每個頁面都需要相同的導覽標籤。

但也許，情況並非如此。 您可能希望為導覽中代表&#x200B;_目前頁面_&#x200B;的項目呈現不同的標籤。

```
Travel Destinations

<ul class="maninnav">
  <li class="currentPage">Travel Destinations
    <ul>
      <li>Finland
      <li>Canada
      <li>Norway
    </ul>
  <li>News
  <li>About us
<ul>
```

```
News

<ul class="maninnav">
  <li>Travel Destinations
  <li class="currentPage">News
    <ul>
      <li>Winter is coming>
      <li>Calm down in the wild
    </ul>
  <li>About us
<is
```

這是兩種完全不同的解讀。 但是，_business對象_ —— 完整的導航樹——是相同的。  此處的&#x200B;_business對象_&#x200B;將是表示樹中節點的對象圖。 此圖形可輕鬆儲存在記憶體內快取中。 但請記住，此圖形不得包含您未自行建立的任何物件或參考任何物件——尤其是現在的JCR節點。

#### 在瀏覽器中快取

我們已注意到在瀏覽器中快取的重要性，而且有許多好的教學課程。 最後，對於瀏覽器，Dispatcher只是遵循HTTP通訊協定的Web伺服器。

然而，儘管有這樣的理論，我們收集了一些知識，這些知識我們沒有發現，我們想分享。

實際上，瀏覽器快取可以以兩種不同的方式運用，

1. 瀏覽器有快取的資源，它知道確切的到期日。 在這種情況下，它不會再次請求資源。

2. 瀏覽器有資源，但無法確定它是否仍然有效。 在這種情況下，它會詢問webserver（本例中為Dispatcher）。 如果自您上次傳送資源以來已修改，請將資源提供給我。 如果未變更，伺服器會回答「304 —— 未變更」，且只傳送中繼資料。

#### 除錯

如果您正在最佳化Dispatcher設定以進行瀏覽器快取，在瀏覽器和webserver之間使用案頭代理伺服器非常有用。 我們更喜歡卡爾·馮·蘭道的《查爾斯網路除錯代理》。

使用Charles，您可以讀取傳送至伺服器或從伺服器傳送的要求和回應。 此外，您還可以瞭解HTTP通訊協定。 現代瀏覽器也提供一些除錯功能，但案頭代理的功能是前所未有的。 您可以控制傳輸的資料、限制傳輸、重放單一請求等。 用戶介面佈局清晰，相當全面。

最基本的測試是將網站當做一般使用者使用（代理介於之間），並在靜態要求（對/etc/...）的數目隨時間變少時簽入proxy，因為這些要求應該在快取中，而不再被要求。

我們發現，Proxy可能會提供更清楚的概述，因為快取的請求不會出現在記錄檔中，而有些瀏覽器內建的除錯程式仍會以「0毫秒」或「從磁碟」顯示這些請求。 這樣可以，也準確，但可能會讓您的檢視蒙上一層陰影。

然後，您可以深入檢視並檢查已傳輸檔案的標題，以查看（例如，&quot;Expires&quot; http標題是否正確）。 您可以重播請求，設定if-modified-since標題，以查看伺服器是否正確回應304或200回應代碼。 您可以觀察非同步呼叫的時間，也可以在一定程度上測試您的安全性假設。 記住，我們告訴您不要接受所有未明確預期的選擇器？ 您可以在這裡播放URL和參數，並查看您的應用程式是否運作良好。

在除錯快取時，我們只會要求您不要做一件事：

請勿在瀏覽器中重新載入頁面！

「瀏覽器重新載入」、_simple-reload_&#x200B;以及&#x200B;_forced-reload_(&quot;_shift-reload_&quot;)與一般頁面要求不同。 簡單的重新載入請求會設定標題

```
Cache-Control: max-age=0
```

而Shift-Reload（在按一下重新載入按鈕時按住&quot;Shift&quot;鍵）通常會設定請求標題

```
Cache-Control: no-cache
```

兩個標題的效果類似但略有不同——但最重要的是，當您從URL位置開啟URL或使用網站上的連結時，它們與一般要求完全不同。 一般瀏覽不會設定「快取控制」標題，但可能會是if-modified-since標題。

因此，如果您想要除錯一般瀏覽行為，您應該正確執行下列動作：_正常瀏覽_。 使用瀏覽器的重新載入按鈕是在設定中看不到快取設定錯誤的最佳方式。

使用您的Charles Proxy查看我們在說什麼。 是的，當您開啟時，您可以直接重播請求。 不需要從瀏覽器重新載入。

## 效能測試

透過使用Proxy，您就可瞭解頁面的時機行為。 當然，這還遠不是效能測試。  效能測試需要同時要求您頁面的多個用戶端。

我們常常看到的一個常見錯誤是，效能測試只包括超小的頁數，而這些頁只從Dispatcher快取中傳送。

如果您要將應用程式提升至即時系統，則負載與您測試的完全不同。

在即時系統中，存取模式並非您在測試中所擁有的平均分佈頁面數目少（首頁和內容頁數少）。 頁面數量大得多，請求的分佈也很不均勻。 當然，即時頁面無法從快取100%提供：來自發佈系統的失效請求會自動使貴用戶的大量寶貴資源失效。

是的，當您重建Dispatcher快取時，您會發現，Publish系統的運作方式也有很大不同，這取決於您是只請求少數幾個頁面，還是請求較多頁面。 即使所有頁面都同樣複雜，它們的編號也起到一定作用。 還記得我們說過的鏈式快取嗎？ 如果您總是要求相同數量的頁面，則很有可能是，含有原始資料的相應區塊位於硬碟快取中，或是由作業系統快取區塊。 此外，資料庫很有可能已在其主記憶體中快取了相應的段。 因此，重新轉譯的速度比您讓其他頁面立即逐出，然後從各種快取中驅逐時要快得多。

快取很困難，對依賴快取的系統進行測試也是一樣。 那麼，你能做什麼讓現實生活更加精確？

我們認為您必須執行多個測試，而且您必須提供多個效能指標來衡量解決方案的品質。

如果您已有現有網站，請測量請求數以及請求的分發方式。 嘗試建立使用類似請求分佈之測試的模型。 增加一些隨機性是無妨的。 您不需要模擬瀏覽器來載入靜態資源，例如JS和CSS —— 這些並不重要。 它們最終會在瀏覽器或Dispatcher中快取，而且不會大幅增加負載。 但參考影像確實很重要。 在舊的記錄檔中尋找其散發，並建立類似的請求模式模型。

現在，請對Dispatcher執行測試，而不是快取。 這是你最壞的情況。 瞭解您的系統在最糟糕的情況下，在最高負載下會變得不穩定。 您也可以視需要取出一些Dispatcher/Publish腿部，讓情況更糟。

接著，對「開啟」的所有必要快取設定進行相同的測試。 緩慢地提高並行請求，以暖化快取，並查看在這些最佳情況下，系統可以承受多少費用。

平均情況是，在啟用Dispatcher的情況下運行測試，但同時發生一些無效情況。 您可以通過cronjob觸碰statfiles或以不規則間隔將失效請求發送到Dispatcher來模擬此情況。 不要忘記時不時清除一些非自動失效的資源。

您可以增加失效請求並增加負載，以改變最後一個藍本。

這比線性負載測試要複雜一些——但讓您對解決方案更有信心。

你可能會逃避努力。 但是，在Publish系統上至少要進行最壞的案例測試，以檢視系統的限制。 請確定您正確解譯最佳案例的數目，並為系統提供足夠的空間。