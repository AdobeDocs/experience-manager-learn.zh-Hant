---
title: 「第3章 — 進階Dispatcher快取主題」
description: 這是AEM快取的三部分系列中的第3部分。 前兩個部分著重於Dispatcher中的普通http快取，以及有哪些限制。 本部分討論如何克服這些限制的一些想法。
feature: Dispatcher
topic: Architecture
role: Architect
level: Intermediate
exl-id: 7c7df08d-02a7-4548-96c0-98e27bcbc49b
source-git-commit: 4b47daf82e27f6bea4be30e3cdd132f497f4c609
workflow-type: tm+mt
source-wordcount: '6187'
ht-degree: 0%

---

# 第3章 — 進階快取主題

*「在電腦科學中，只有兩個硬體：快取失效和命名專案。」*

 — 菲爾·卡爾頓

## 概觀

這是AEM快取的三部分系列中的第3部分。 前兩個部分著重於Dispatcher中的普通http快取，以及有哪些限制。 本部分討論如何克服這些限制的一些想法。

## 一般快取

[第1章](chapter-1.md) 和 [第2章](chapter-2.md) 主要針對Dispatcher。 我們已說明基本知識、限制以及您需要進行某些權衡的位置。

快取複雜性和複雜性並非Dispatcher特有的問題。 一般而言，快取相當困難。

在工具箱中將Dispatcher設為唯一工具實際上是個真正的限制。

在本章中，我們想要進一步擴大對於快取的檢視，並想提出一些有關如何克服Dispatcher某些缺點的想法。 沒有萬靈丹 — 您必須在專案中進行權衡。 請記住，快取和失效準確性總是伴隨著複雜性，複雜性總是伴隨著錯誤的可能性。

您需要在這些領域進行權衡，

* 效能和延遲
* 資源消耗/CPU負載/磁碟使用量
* 準確性/貨幣/過時/安全性
* 簡易性/複雜性/成本/可維護性/錯誤傾向

這些維度在相當複雜的系統中相互連結。 沒有簡單的if-this-then-that。 讓系統更簡單可使其更快或更慢。 它可以降低您的開發成本，但會增加服務檯的成本，例如，如果客戶看到過時內容或抱怨網站速度緩慢，就會增加成本。 所有這些因素都必須加以考量，並加以平衡。 但現在您已經有一個好點子了，沒有靈丹妙藥或只有一個「最佳實務」，只有許多不良實務和幾個好的實務。

## 鏈結快取

### 概觀

#### 資料流程

從伺服器傳送頁面至使用者端的瀏覽器，可跨越許多系統和子系統。 若您仔細檢視，需從來源資料提取多個躍點至漏資料，每個躍點資料都可能是快取的候選資料。

![典型CMS應用程式的資料流程](assets/chapter-3/data-flow-typical-cms-app.png)

*典型CMS應用程式的資料流程*

<br> 

讓我們從硬碟上需要顯示在瀏覽器中的資料片段開始歷程。

#### 硬體與作業系統

首先，硬碟機(HDD)本身在硬體中有一些內建的快取記憶體。 其次，裝載硬碟的作業系統使用可用記憶體來快取經常存取的區塊，以加快存取速度。

#### 內容儲存庫

下一個層級是CRX或Oak - AEM使用的檔案資料庫。 CRX和Oak會將資料分割成區段，以便在記憶體中快取，同時避免存取硬碟的速度變慢。

#### 第三方資料

大多數較大的Web安裝也有第三方資料；資料來自產品資訊系統、客戶關係管理系統、舊版資料庫或任何其他任意Web服務。 我們不需要在需要時隨時從來源提取這些資料，尤其是在我們已知資料變更頻率不太高的情況下。 因此，如果它未在CRX資料庫中同步，則可以快取。

#### 業務層 — 應用程式/模型

通常您的範本指令碼不會透過JCR API轉譯來自CRX的原始內容。 最有可能的情況是，您之間有業務層，可合併、計算及/或轉換業務網域物件中的資料。 猜猜會怎樣 — 如果這些操作很昂貴，您應該考慮快取它們。

#### 標籤片段

模型現在是呈現元件標示的基礎。 為什麼不同時快取演算後的模型？

#### Dispatcher、CDN和其他代理

關閉會將轉譯後的HTML頁面傳送到Dispatcher。 我們已討論過，Dispatcher的主要目的是快取HTML頁面和其他網頁資源（儘管其名稱）。 在資源到達瀏覽器之前，它可能會傳遞反向Proxy （可以快取）和CDN （也用於快取）。 使用者端可能位於辦公室中，僅透過Proxy授與Web存取權，該Proxy可能決定快取並儲存流量。

#### 瀏覽器快取

最後但並非最不重要的一點是，瀏覽器也會快取。 這是容易被忽略的資產。 但這是您在快取鏈結中最接近且最快的快取。 很遺憾，此資訊不會在使用者之間共用，但仍會在一個使用者的不同請求之間共用。

### 快取的位置及原因

這是一長串潛在快取記憶體。 我們都遇到過問題，看到過時的內容。 但是考慮到這個階段有幾個，它大部分時間都運作起來是個奇蹟。

但快取在鏈條的哪個位置才有意義？ 在開頭？ 在結尾？ 到處都是？ 這取決於……而且取決於許多因素。 即使是相同網站中的兩個資源，也可能希望針對該問題獲得不同的答案。

為了讓您大致瞭解可能考慮的因素，

**存留時間**  — 如果物件的內在存留時間較短（流量資料的存留時間可能比天氣資料短），可能不值得快取。

**生產成本 —** 物件的再生產與傳送是多麼昂貴（就CPU週期和I/O而言）。 如果是廉價快取，可能就不需要了。

**大小**  — 大型物件需要快取更多資源。 這可能是限制因素，必須與其收益相平衡。

**存取頻率**  — 如果物件很少被存取，快取可能無效。 在第二次從快取存取之前，它們只會過時或失效。 這類專案只會封鎖記憶體資源。

**共用存取**  — 應由多個實體使用的資料在鏈的上方快取。 實際上，快取鏈不是鏈，而是樹。 一個以上的模型可能會使用存放庫中的一個資料。 這些模型進而可供多個轉譯指令碼用來產生HTML片段。 這些片段包含在多個頁面中，這些頁面會分發給多個使用者，並在瀏覽器中使用其私人快取。 因此，「共用」並不表示只在人與人之間共用，而是在軟體之間共用。 如果您想要尋找潛在的「共用」快取，只要將樹追溯到根並尋找共同祖先即可 — 也就是您應該快取的位置。

**地理空間分佈**  — 如果您的使用者分散在世界各地，使用分散的快取網路可能有助於減少延遲。

**網路頻寬和延遲**  — 說到延遲，您的客戶是誰，他們使用哪種網路？ 或許您的客戶是使用舊一代智慧型手機3G連線的缺發達國家行動客戶？ 請考慮建立較小的物件，並在瀏覽器快取中快取它們。

這份清單目前還不完整，但我們認為您現在已經有了想法。

### 鏈結快取的基本規則

再說一次 — 快取是硬的。 讓我們分享我們從先前專案摘錄的一些基本規則，這些規則可幫助您避免專案中出現問題。

#### 避免雙重快取

上一章介紹的每個層都會提供快取鏈結中的某些值。 或是節省運算週期，或是讓資料更貼近消費者。 在鏈結的多個階段快取資料片段並沒有錯，但您應該一律考量下一個階段的好處和成本。 在Publish系統中快取完整頁面通常不會提供任何好處，因為這項操作在Dispatcher中已經完成。

#### 混合失效策略

有三種基本失效策略：

* **TTL、存留時間：** 物件會在固定時間後到期（例如「從現在起的2小時」）
* **到期日：** 物件會在未來定義的時間過期（例如「2019年6月10日下午5:00」）
* **基於事件：** 物件會因平台中發生的事件而明確失效（例如，當頁面變更並啟動時）

現在，您可以在不同的快取層上使用不同的策略，但有一些「有毒」的策略。

#### 事件型失效

![純事件型失效](assets/chapter-3/event-based-invalidation.png)

*純事件型失效：從內部快取到外層失效*

<br> 

純事件型失效是最容易理解、最容易在理論上正確且最精確的失效方式。

簡言之，物件變更後，快取會逐一失效。

您只需要記住一個規則：

一律從內部到外部快取失效。 如果您先讓外部快取失效，它可能會從內部快取重新快取過時內容。 不要在快取重新整理的時間做任何假設 — 請確定。 最佳作法是觸發外部快取失效 _晚於_ 使內部節點失效。

這就是理論了。 但實際上有許多疑問。 事件必須分發 — 可能透過網路。 在實務中，這會使失效配置最難實作。

#### 自動 — 修復

若使用事件型失效，您應該有應急計畫。 如果遺漏失效事件，該怎麼辦？ 一個簡單的策略可能是在一段時間後讓無效或清除。 因此，您可能已錯過該活動，現在提供過時的內容。 但您的物件也只有數小時（天）的隱含TTL。 所以最終系統會自動自我修復。

#### 純TTL型失效

![未同步的TTL型失效](assets/chapter-3/ttl-based-invalidation.png)

*未同步的TTL型失效*

<br> 

這個方案也是相當常見的方案。 您可以棧疊多個快取層，每個層都有權在特定時間內提供物件。

實作容易。 不幸的是，很難預測資料片段的有效壽命。

![延長內部物件生命週期的外框](assets/chapter-3/outer-cache.png)

*延長內部物件壽命的外部快取*

<br> 

請考量上圖。 每個快取層都會引入2分鐘的TTL。 現在 — 整體TTL也必須2分鐘，對嗎？ 不盡然。 如果外層在物件過期之前擷取物件，外層實際上會延長物件的有效存留時間。 在這種情況下，有效上線時間可介於2到4分鐘之間。 假設您同意業務部門的意見，一天是可以容忍的 — 而且您有四個快取階層。 每個圖層上的實際TTL不可超過六小時……增加快取遺漏率……

我們並不是說這是一個糟糕的配置。 您應該知道它的限制。 而且這是一個簡單好用的策略。 只有在網站的流量增加時，您才可以考慮更精確的策略。

*透過設定特定日期來同步失效時間*

#### 基於到期日的失效

如果您在內部物件上設定特定日期，並將其傳播至外部快取，則可獲得更可預測的有效期限。

![同步到期日](assets/chapter-3/synchronize-expiration-dates.png)

*同步到期日*

<br> 

不過，並非所有快取都能傳播日期。 而且，當外部快取彙總了兩個具有不同到期日的內部物件時，可能會變得噁心。

#### 混合事件型和TTL型失效

![混合事件型和TTL型策略](assets/chapter-3/mixing-event-ttl-strategies.png)

*混合事件型和TTL型策略*

<br> 

AEM世界中另一個常見的結構是在內部快取（例如記憶體中的快取，事件可以近乎即時地處理）以及外部的TTL型快取（您可能無權存取明確失效）中使用事件型失效。

在AEM世界中，當基礎資源變更時，並且您將此變更事件傳播到也可使用基於事件的Dispatcher時，在Publish系統中會有用於商業物件和HTML片段的記憶體快取，即會失效。 例如，您前面會有一個以TTL為基礎的CDN。

在Dispatcher前面有一層（短）TTL型快取，能夠有效地緩和自動失效後通常會出現的尖峰。

#### 混合TTL — 和事件型失效

![混合TTL — 和事件型失效](assets/chapter-3/toxic.png)

*有毒：混合TTL — 和事件型失效*

<br> 

這種組合是有毒的。 切勿在TTL或到期型快取之後放置和事件型快取。 還記得我們在「純TTL」策略中的溢位效應嗎？ 相同的效果可以在這裡觀察到。 只有外部快取的失效事件已經發生，才會不再發生。如此一來，您快取物件的壽命就會無限延長。

![TTL型和事件型合併：溢位至無限](assets/chapter-3/infinity.png)

*TTL型和事件型合併：溢位至無限*

<br> 

## 部分快取和記憶體內部快取

您可以掛接至演算程式的階段來新增快取圖層。 從取得遠端資料傳輸物件或建立本機商務物件，到快取單一元件的演算標籤。 我們將在稍後的教學課程中討論具體實施。 但您可能打算自己已經實作一些這樣的快取圖層。 因此，我們在這裡至少可以介紹基本原則，以及各種問題。

### 警告字詞

#### 遵循存取控制

這裡所描述的技巧非常強大且 _必須 — 擁有_ 每個AEM開發人員的工具箱中。 但別太興奮，明智地使用它們。 將物件儲存在快取中並在後續請求中分享給其他使用者，實際上意味著規避存取控制。 這在對外公開的網站上通常不是問題，但在使用者需要登入才能取得存取權時，可能會是問題。

假設您將網站主功能表的HTML標籤儲存在記憶體中的快取中，以便在不同頁面之間共用。 實際上，這是儲存部分轉譯HTML的完美範例，因為建立導覽通常很昂貴，因為它需要遍歷許多頁面。

您並非在所有頁面之間共用相同的功能表結構，而是與所有使用者共用，因此效率更高。 但請稍候……但可能功能表中有些專案僅供特定使用者群組使用。 在這種情況下，快取可能會變得較為複雜。

#### 僅快取自訂商務物件

如果有的話 — 這是最重要的建議，我們可以為您提供：

>[!WARNING]
>
>只有屬於您的物件、不可變、您自行建置、淺層且沒有外送參照的快取物件。

這是什麼意思？

1. 您不知道其他人物件的預期即時週期。 假設您取得請求物件的參考，並決定快取該參考。 現在，請求已結束，並且servlet容器想要將該物件回收以供下一個傳入請求使用。 在這種情況下，其他人正在變更您認為擁有獨佔控制權的內容。 不要對此嗤之以鼻 — 我們曾在專案中看到過類似的情況。 客戶看到其他客戶資料，而不是他們自己的資料。

2. 只要物件被其他參照鏈所參照，就無法從棧積中移除該物件。 如果您在快取中保留參考的所謂小型物件，假設影像以4MB呈現，您很有可能遇到記憶體洩漏的問題。 快取應該以弱參照為基礎。 但 — 弱參考無法如您預期般運作。 這是產生記憶體洩漏並因記憶體不足錯誤而結束的最佳方法。 而且 — 您不知道外部物件的保留記憶體大小是多少，對吧？

3. 尤其是在Sling中，您可以使每個物件彼此相適應（幾乎）。 假設您將資源放入快取中。 下一個請求（具有不同的存取許可權）會擷取該資源，並將其調整到resourceResolver或工作階段以存取他無法存取的其他資源。

4. 即使您從AEM在資源周圍建立精簡「包裝函式」，也不得快取該專案，即使它是您自己的且不可變動。 包裝的物件將成為參考（我們之前禁止使用），如果我們看起來很銳利，基本上會產生與最後一個專案中所述相同的問題。

5. 如果您想要快取，請將原始資料複製到您自己的快取物件中，以建立您自己的物件。 您可能想要透過參照來連結您自己的物件之間 — 例如，您可能想要快取物件的樹狀結構。 沒關係 — 但只有您剛在相同請求中建立的快取物件 — 而且沒有從其他位置請求的物件（即使是「您的」物件的名稱空間）。 _複製物件_ 是金鑰。 同時請務必立即清除連結物件的整個結構，並避免傳入和傳出對結構的參照。

6. 是 — 並且讓您的物件不可變動。 私有屬性，僅限且無設定器。

這是許多規則，但值得遵循。 即使您經驗豐富、超級聰明，並且一切都在掌控之中。 您專案中的年輕同事剛從大學畢業。 他不知道所有這些陷阱。 如果沒有陷阱，就沒有什麼可避免的。 簡單明瞭，容易理解。

### 工具和程式庫

此系列旨在瞭解概念，並讓您能夠建立最符合使用案例的架構。

我們並未特別推廣任何工具。 但會提供如何評估它們的提示。 例如，自6.0版開始，AEM就有一個具有固定TTL的簡單內建快取。您使用它嗎？ 可能不在發佈中，事件型快取會依循在鏈結中（提示：Dispatcher）。 但作者可能選擇得體。 AdobeACS Commons也有HTTP快取，這點可能值得考慮。

或者，您根據成熟的快取架構，建置自己的快取架構，例如 [Ehcache](https://www.ehcache.org). 這可用於快取Java物件和演算標籤(`String` 物件)。

在某些簡單情況下，您也可以使用同時雜湊對應 — 在這裡，您很快就會看到工具或技能的限制。 和命名和快取一樣難以掌握並行性。

#### 引用

* [ACS Commons http快取 ](https://adobe-consulting-services.github.io/acs-aem-commons/features/http-cache/index.html)
* [快取快取架構](https://www.ehcache.org)

### 基本術語

我們不會在此深入探討快取理論，但我們覺得有必要提供幾個流行語，好讓您有一個良好的開始。

#### 快取逐出

我們經常談到失效和清除。 _快取逐出_ 與下列詞語相關：專案被逐出後，即不再可用。 但是逐出不會發生在專案過時時，而是發生在快取已滿時。 較新或「較重要」的專案會將較舊或較不重要的專案推送出快取。 您必須犧牲哪些專案，取決於個案情況。 您可能會想要逐出最舊的，或是很少使用或最後存取時間很長的專案。

#### 搶佔式快取

搶佔式快取表示在專案失效或被視為過時時，以新的內容重新建立專案。 當然 — 您只需使用少數資源，確保可以經常且立即存取。 否則，您可能會浪費資源來建立可能永遠不會被請求的快取專案。 藉由預先建立快取專案，您可以減少快取失效後對資源的第一個要求的延遲。

#### 快取預熱

快取預熱與搶佔式快取密切相關。 不過您不會將該辭彙用於即時系統。 而且時間限制也比前者少。 您不會在失效後立即重新快取，但在時間允許時您會逐漸填入快取。

例如，您從負載平衡器取出Publish / Dispatcher程式碼以更新它。 在重新整合之前，您會自動對最常存取的頁面進行編目，以便將其重新放入快取。 當快取為「暖和」 — 填滿足夠時，您會將支腳重新整合到負載平衡器中。

或者，您可能會一次重新整合該腿，但您會將流量節流到該腿，這樣它就有機會透過正常使用來暖化其快取。

或者，您也可以在系統閒置時，快取某些不常存取的頁面，以減少實際請求存取這些頁面時的延遲。

#### 快取物件身分、裝載、失效相依性和TTL

一般而言，快取物件或「專案」有五個主要屬性，

#### 金鑰

此身分是您用來識別和物件的屬性。 擷取其裝載或從快取中清除它。 例如，Dispatcher使用頁面的URL作為索引鍵。 請注意，Dispatcher不會使用頁面路徑。 這不足以區分不同的呈現。 其他快取可能使用不同的索引鍵。 我們稍後會看到一些範例。

#### 值/裝載

這是物件的寶庫，也就是您要擷取的資料。 如果是Dispatcher，則為檔案內容。 但它也可以是Java物件樹。

#### TTL

我們已經涵蓋TTL。 在此時間後，系統會將專案視為過時，且不應再傳送專案。

#### 相依性

這與事件型失效相關。 物件會根據哪些原始資料？ 我們已經說過，在第一部分中，真實且準確的相依性追蹤太複雜。 但只要瞭解系統的知識，您就可以使用更簡單的模型來近似相依性。 我們讓足夠多的物件失效，以清除過時的內容……而且可能無意間超過了所需的數量。 然而，我們仍試圖保持在「清除所有內容」之下。

哪些物件取決於每個單一應用程式中的其他物件為真品。 我們稍後會提供一些如何實作相依性策略的範例。

### HTML片段快取

![在不同頁面上重複使用演算後的片段](assets/chapter-3/re-using-rendered-fragment.png)

*在不同頁面上重複使用演算後的片段*

<br> 

HTML片段快取是一個強大的工具。 其想法是快取記憶體內部快取中元件產生的HTML標籤。 您可能會問，為什麼我應該這麼做？ 我反正在Dispatcher中快取整個頁面的標籤 — 包括該元件的標籤。 我們同意。 您可以 — 但每頁一次。 您並未在頁面之間共用該標籤。

想像一下，您正在每個頁面上方呈現導覽。 每個頁面上的標籤看起來都一樣。 但您會針對每個頁面不斷重複轉譯，這不在Dispatcher中。 並記住：自動失效後，所有頁面都需要重新呈現。 基本上，您執行相同的程式碼會產生數百次相同的結果。

根據我們的經驗，演算巢狀頂端導覽是一項非常昂貴的工作。 通常，您會遍歷檔案樹狀結構的大部分來產生導覽專案。 即使您只需要導覽標題和URL — 頁面必須載入記憶體。 而在這裡，它們正在阻塞寶貴的資源。 一遍又一遍。

但元件會在許多頁面之間共用。 而共用某物件即表示使用快取。 所以 — 您要做的就是檢查導覽元件是否已轉譯及快取，而不要重新轉譯而是隻發出快取值。

這個方案有兩個很好的細節，很容易被忽略：

1. 您正在快取Java字串。 String沒有任何外寄參考，且不可變動。 因此，考慮到上述警告，這是超級安全的。

2. 此外，失效也非常簡單。 每當有內容變更您的網站時，您都會想要讓此快取專案失效。 重建相對便宜，因為它只需要執行一次，然後會被數百頁重複使用。

這可讓您的Publish伺服器輕鬆許多。

### 片段快取實作

#### 自訂標籤

過去，您會使用JSP當做範本引擎，使用自訂JSP標籤來包裝元件轉譯程式碼相當常見。

```
<!-- Pseudo Code -->

<myapp:cache
  key=' ${info.homePagePath} + ${component.path}'
  cache='main-navigation'
  dependency='${info.homePagePath}'>

… original components code ..

</myapp:cache>
```

比會擷取其內文並將其寫入快取中的自訂標籤，或是會阻止執行其內文並改為輸出快取專案的裝載。

「索引鍵」是其在首頁上的元件路徑。 我們不使用目前頁面上的元件路徑，因為這麼做會在每頁建立一個快取專案，與我們共用該元件的意圖相悖。 我們也不是只使用元件相對路徑(`jcr:conten/mainnavigation`)，因為這會防止我們在不同網站中使用不同的導覽元件。

「快取」是儲存專案的指示器。 您通常有多個快取，可將專案儲存至其中。 其中每個選項的行為可能會稍有不同。 因此，區分儲存的內容是件好事，即便最終只是字串。

「相依性」這是快取專案相依的專案。 「主要導覽」快取可能有規則，說明如果節點「相依性」下有任何變更，則必須清除相應的專案。 因此 — 您的快取實作需要將其自身註冊為存放庫中的事件偵聽程式，以瞭解變更，然後套用快取特定規則以找出需要失效的內容。

以上只是一個範例。 您也可以選擇建立快取樹狀結構。 其中第一層用來分隔網站（或租使用者），第二層則分支出各種內容（例如「主要導覽」），讓您可省去新增首頁路徑的麻煩，如上述範例所示。

順便一提，您也可以將此方法用於更現代化的HTL元件。 然後，您的HTL指令碼周圍會有一個JSP包裝函式。

#### 元件篩選器

但在純HTL方法中，您寧可使用Sling元件篩選器建置片段快取。 我們尚未看到這點，但我們將針對此問題採取此方法。

#### Sling Dynamic包含

如果您在不斷變化的環境（不同頁面）中有某些常數（導覽），則會使用片段快取。

但您也可能有相反的情況，相對固定的內容（很少變更的頁面）和該頁面上一些不斷變化的片段（例如，即時滾動文字）。

在此情況下，您可以 [Sling Dynamic Include](https://sling.apache.org/documentation/bundles/dynamic-includes.html) 機會。 本質上，這是元件篩選，它會包裝動態元件，而不是將元件呈現至其建立參照的頁面。 此參考可以是Ajax呼叫，好讓瀏覽器包含元件，進而以靜態方式快取周圍的頁面。 或者，或者，Sling Dynamic Include可以產生SSI指令（伺服器端包含）。 此指示詞會在Apache伺服器中執行。 如果您利用Varnish或支援ESI指令碼的CDN，您甚至可以使用ESI - Edge Side Include指令。

![使用Sling Dynamic Include的請求順序圖](assets/chapter-3/sequence-diagram-sling-dynamic-include.png)

*使用Sling Dynamic Include的請求順序圖*

<br> 

SDI檔案說明您應停用結尾為&quot;*.nocache.html&quot;的URL的快取，這有意義 — 當您處理動態元件時。

您可能會看到如何使用SDI的另一個選項：如果您 _不要_ 停用include的Dispatcher快取，Dispatcher的運作方式就像片段快取，類似於我們在上一章中描述的快取：頁面和元件片段會平等且獨立地在Dispatcher中快取，並在請求頁面時由Apache伺服器中的SSI指令碼拼接在一起。 如此一來，您就可以實作共用元件，例如主要導覽（假設您一律使用相同的元件URL）。

理論上，這應該有效。 但是……

我們建議您不要這麼做：您將失去略過實際動態元件快取的能力。 SDI已全域設定，您對「poor-mans-fragment-cache」所做的變更也會套用至動態元件。

建議您仔細研究SDI檔案。 還有其他幾項限制，但在某些情況下SDI是很有價值的工具。

#### 引用

* [docs.oracle.com — 如何撰寫自訂JSP標籤](https://docs.oracle.com/cd/E11035_01/wls100/taglib/quickstart.html)
* [Dominik Suss — 建立和使用元件篩選器](https://www.slideshare.net/connectwebex/prsentation-dominik-suess)
* [sling.apache.org - Sling Dynamic Include](https://sling.apache.org/documentation/bundles/dynamic-includes.html)
* [helpx.adobe.com — 在AEM中設定Sling Dynamic Include](https://helpx.adobe.com/experience-manager/kt/platform-repository/using/sling-dynamic-include-technical-video-setup.html)


#### 模型快取

![以模型為基礎的快取：一個商業物件，具有兩個不同的轉譯](assets/chapter-3/model-based-caching.png)

*以模型為基礎的快取：一個商業物件，具有兩個不同的轉譯*

<br> 

讓我們再次透過導覽重新造訪案例。 我們假設每個頁面都需要相同的導覽標籤。

但或許情況並非如此。 您可能會想要為導覽中代表 _目前頁面_.

```
Travel Destinations

<ul class="maninnav">
  <li class="currentPage">Travel Destinations
    <ul>
      <li>Finland
      <li>Canada
      <li>Norway
    </ul>
  <li>News
  <li>About us
<ul>
```

```
News

<ul class="maninnav">
  <li>Travel Destinations
  <li class="currentPage">News
    <ul>
      <li>Winter is coming>
      <li>Calm down in the wild
    </ul>
  <li>About us
<is
```

以下是兩個完全不同的轉譯。 然而， _業務物件_  — 完整的導覽樹狀結構 — 是相同的。  此 _業務物件_  這裡會有一個物件圖表，代表樹狀結構中的節點。 此圖表可輕鬆儲存在記憶體中的快取記憶體中。 不過請記住，此圖表不得包含任何物件或參考您未自行建立的任何物件，尤其是現在的JCR節點。

#### 在瀏覽器中快取

我們之前已提到瀏覽器中快取的重要性，並且有許多不錯的教學課程。 最後，對於瀏覽器，Dispatcher只是一個遵循HTTP通訊協定的Web伺服器。

然而，儘管理論不明，我們還是收集了一些我們別無他法、並且想要分享的知識。

本質上，瀏覽器快取可以透過兩種不同的方式運用，

1. 瀏覽器已快取其知道確切到期日的資源。 在這種情況下，它不會再請求資源。

2. 瀏覽器有資源，但不確定其是否仍然有效。 在這種情況下，它會詢問網頁伺服器（在此例中是Dispatcher）。 如果自您上次傳遞資源後資源已修改，請將資源給我。 如果未變更，則伺服器會以「304 — 未變更」回應，並只傳輸中繼資料。

#### 偵錯

如果您正在最佳化Dispatcher設定以進行瀏覽器快取，在瀏覽器和Web伺服器之間使用案頭Proxy伺服器會非常有用。 我們偏好使用Karl von Randow的「Charles Web Debugging Proxy」。

您可以使用Charles讀取傳送至伺服器和從伺服器傳送的請求和回應。 此外，您也可以深入瞭解HTTP通訊協定。 現代瀏覽器也提供一些偵錯功能，但案頭Proxy的功能是前所未有的。 您可以操控傳輸的資料、限制傳輸、重播單一請求等等。 而且使用者介面配置清晰，相當全面。

最基本的測試是以一般使用者的身分使用網站（Proxy介於兩者之間），並在靜態要求（至/etc/...）的數量隨著時間逐漸減少時簽入Proxy — 因為這些要求應該在快取中，不再要求。

我們發現，Proxy可提供更清晰的概述，因為快取的要求不會出現在記錄中，而有些瀏覽器內建的偵錯工具仍會以「0毫秒」或「從磁碟」顯示這些要求。 這很正常，也很準確，但可能會讓您的檢視有些模糊。

然後，您可以向下展開並檢查已傳輸檔案的標頭，以檢視「Expires」http標頭是否正確之類的問題。 您可以使用if-modified-since標頭重播請求，以檢視伺服器是否正確回應304或200回應代碼。 您可以觀察非同步呼叫的時間，也可以在一定程度上測試您的安全性假設。 請記住，我們曾告訴您不要接受所有非明確預期的選取器？ 您可以在這裡玩URL和引數，看看應用程式是否運作良好。

當您對快取進行偵錯時，我們只會要求您不要做一件事：

請勿在瀏覽器中重新載入頁面！

「瀏覽器重新載入」、a _simple-reload_ 以及 _強制重新載入_ (&quot;_shift-reload_「)與一般頁面請求不同。 簡單的重新載入要求會設定標頭

```
Cache-Control: max-age=0
```

而Shift — 重新載入（按住Shift鍵並按一下重新載入按鈕）通常會設定請求標頭

```
Cache-Control: no-cache
```

這兩個標題的效果相似但稍微不同，但最重要的是，當您從URL位置開啟URL或在網站上使用連結時，它們與一般請求完全不同。 一般瀏覽不會設定Cache-Control標頭，但可能是if-modified-since標頭。

因此，如果您想要偵錯正常的瀏覽行為，您應該完全按照以下步驟進行： _正常瀏覽_. 使用瀏覽器的重新載入按鈕是看不到設定中快取設定錯誤的最佳方式。

使用您的Charles Proxy來檢視我們正在討論的內容。 是，而且當您開啟它時，您可以在此重新執行請求。 無需從瀏覽器重新載入。

## 效能測試

透過使用Proxy，您可以瞭解頁面的計時行為。 當然，這遠不是效能測試。  效能測試需要許多使用者端同時要求您的頁面。

一個常見的錯誤（我們經常看到）是效能測試僅包括極少數的頁面，而且這些頁面僅從Dispatcher快取傳送。

如果您要將應用程式升級至即時系統，則負載與您測試過的完全不同。

在即時系統上，存取模式並不是您在測試中（首頁和少數內容頁面）擁有之數量較少且平均分佈的頁面。 頁數更大，而且請求分佈非常不均勻。 而且 — 當然 — 無法從快取中100%提供即時頁面：來自發佈系統的失效請求會使您大部分的寶貴資源自動失效。

是的，而且當您重建Dispatcher快取時，您會發現Publish系統的行為也完全不同，這取決於您請求的是少數頁面還是較大數字。 即使所有頁面都很複雜，它們的數量也會發揮作用。 還記得我們說過關於鏈式快取的話嗎？ 如果您一律要求相同數量的頁面，則作業系統可能會快取含有原始資料的區塊，或這些區塊會位於硬碟快取中。 此外，存放庫也很可能已快取其主要記憶體中的對應區段。 因此，重新呈現的速度會顯著快於其他頁面偶爾從不同快取中逐出時的速度。

快取和測試依賴快取的系統都很困難。 那麼，您可以做些什麼來擁有更精確的真實情境？

我們認為您必須進行多項測試，且您必須提供多項績效指標，以衡量解決方案的品質。

如果您已有網站，請測量要求數量及其分配方式。 嘗試為使用類似請求分佈的測試建模。 新增一些隨機性不會造成傷害。 您不需要模擬會載入JS和CSS等靜態資源的瀏覽器 — 這些其實並不重要。 最後會在瀏覽器或Dispatcher中快取，且這些量度的加總不會顯著增加負載。 但是參考的影像確實重要。 找出它們在舊記錄檔中的分佈，並建立類似請求模式的模型。

現在，在Dispatcher完全沒有快取的情況下進行測試。 這是您最壞的情況。 瞭解在此最惡劣的情況下，您的系統會在哪一個峰值負載變得不穩定。 您也可以視需要取消一些Dispatcher/Publish分支，讓問題變得更糟。

接下來，執行相同的測試，將所有必要的快取設定設為「開啟」。 慢慢增加平行請求，以預熱快取，並瞭解系統在這些最佳情況下可以接受多少。

一般案例會發生在啟用Dispatcher但發生某些無效判定時，同時執行測試。 您可以透過cronjob接觸statfiles或不定期地傳送失效請求給Dispatcher來模擬這種情況。 別忘了偶爾也會清除一些非自動失效的資源。

您可以透過增加失效請求和增加負載來改變最後一種情況。

這比線性負載測試更複雜，但可讓您的解決方案更有信心。

您可能避免費力。 但您至少可以在具有大量頁面（平均分佈）的Publish系統上執行最壞情況的測試，以檢視系統的限制。 請確定您正確解讀最佳案例的數量，並為您的系統布建足夠的空間。
