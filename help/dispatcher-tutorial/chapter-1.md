---
title: "第1章 — Dispatcher概念、模式和反模式"
description: 本章簡要介紹Dispatcher的歷史和機制，並討論這會如何影響AEM開發人員如何設計其元件。
feature: Dispatcher
topic: Architecture
role: Architect
level: Beginner
exl-id: 3bdb6e36-4174-44b5-ba05-efbc870c3520
source-git-commit: b069d958bbcc40c0079e87d342db6c5e53055bc7
workflow-type: tm+mt
source-wordcount: '17460'
ht-degree: 0%

---

# 第1章 — Dispatcher概念、模式和反模式

## 概觀

本章簡要介紹Dispatcher的歷史和機制，並討論這會如何影響AEM開發人員如何設計其元件。

## 為何開發人員應關注基礎結構

Dispatcher是大部分的必要部分，如果不是所有AEM安裝的話。 您可以找到許多線上文章，討論如何設定Dispatcher以及秘訣和技巧。

不過，這些零碎的資訊總是從非常技術性的層面開始 — 假設您已知道要做什麼，因此只提供如何達成所需目標的詳細資訊。 我們從未找到任何概念性檔案來說明 _什麼是，為什麼是_ 關於您可以使用Dispatcher做什麼、不能做什麼的問題。

### 反圖樣：Dispatcher作為事後思考

這種基本資訊的缺乏導致了許多反模式，我們在許多AEM專案中看到過：

1. 由於Dispatcher安裝在Apache Web Server中，因此需由專案中的「Unix gods」負責對其進行設定。 「凡夫俗子的Java開發人員」不需要擔心這個問題。

2. Java開發人員需要確保他的程式碼可以運作……排程程式稍後會神奇地讓它變快。 Dispatcher一律為事後考量。 但是，這無法運作。 開發人員在設計其程式碼時必須考慮到Dispatcher。 他需要瞭解基本概念才能做到這一點。

### 「先讓它運作 — 然後讓它快速」並非總是正確的

您可能聽過程式設計的建議 _「先讓它運作，然後再讓它快速。」_。並非完全錯誤。 但是，如果沒有正確的上下文，它可能會遭到錯誤解譯且無法正確套用。

此建議應避免開發人員過早最佳化程式碼，因為程式碼可能永遠不會執行，或是執行得太少，以至於最佳化沒有足夠的影響，無法證明將工作投入最佳化。 此外，最佳化可能會導致程式碼變得更加複雜，從而引入錯誤。 因此，如果您是開發人員，請勿將太多時間花在微調最佳化每行程式碼上。 只要確定您選擇正確的資料結構、演演算法和程式庫，並等待效能分析工具的熱點分析，就能知道更徹底的最佳化可以在何處提高整體效能。

### 架構決定與成品

然而，在「架構」決策方面，「先讓它運作，然後讓它快速」的建議是完全錯誤的。 什麼是架構決策？ 簡言之，它們是昂貴、困難和/或事後無法變更的決定。 請記住，「昂貴」有時等同於「不可能」。  例如，當您的專案已用盡預算時，就不可能進行昂貴的變更。 對的基礎架構變更，是這個類別中第一個出現在大多數人腦海中的變更。 但還有另外一種「建築」成品可能會變得非常難改：

1. 許多其他片段所依賴的應用程式「中心」中的程式碼片段。 若變更這些專案，需要一次變更並重新測試所有相依性。

2. 涉及某些非同步、計時相關案例的成品，在這些案例中，輸入以及系統的行為可能隨機變化。 變更可能會產生無法預測的影響，而且可能難以測試。

3. 在系統的所有零件和零件中，反複使用和重複使用的軟體模式。 如果軟體模式並非最佳模式，則所有使用該模式的成品都必須重新編碼。

記憶? 在本頁頂端，我們說過Dispatcher是AEM應用程式的重要部分。 存取網頁應用程式非常隨機 — 使用者在無法預測的時間來來往往。 最後 — 所有內容都將（或應該）在Dispatcher中快取。 因此，如果您密切留意，可能會發現快取可以被視為「架構」成品，因此應該讓團隊的所有成員、開發人員和管理員都瞭解。

我們並不是說開發人員應該實際設定Dispatcher。 他們需瞭解概念（尤其是界限），以確保Dispatcher也能運用其程式碼。

Dispatcher不會奇蹟般地提高程式碼速度。 開發人員在建立元件時，必須考慮到Dispatcher。 因此，他需要知道它是如何運作的。

## Dispatcher快取 — 基本原則

### Dispatcher作為快取Http — 負載平衡器

什麼是Dispatcher？為何最初稱為「Dispatcher」？

Dispatcher是

* 首先也是最重要的一個快取

* 反向Proxy

* 適用於Apache httpd webserver的模組，可將AEM相關功能新增至Apache的多功能性，並與所有其他Apache模組一起順暢運作（例如SSL或甚至SSI包含，我們稍後將看到）

在網路早期，您可能會有幾百位訪客造訪網站。 一個Dispatcher的設定，「已分派」或平衡請求到許多AEM發佈伺服器的負載，這通常已足夠 — 因此，名稱為「Dispatcher」。 然而，現今此設定不再經常使用。

稍後我們會看到設定Dispatcher和Publish系統的不同方式。 首先，讓我們從一些http快取基本概念開始。

![Dispatcher快取的基本功能](assets/chapter-1/basic-functionality-dispatcher.png)

*Dispatcher快取的基本功能*

<br> 

此處說明Dispatcher的基本知識。 Dispatcher是簡單的快取反向Proxy，能夠接收和建立HTTP請求。 正常的要求/回應週期如下：

1. 使用者請求頁面
2. Dispatcher會檢查它是否已擁有該頁面的轉譯版本。 假設這是此頁面的第一個請求，且Dispatcher找不到本機快取復本。
3. Dispatcher會從發佈系統請求頁面
4. 在Publish系統上，頁面會由JSP或HTL範本轉譯
5. 頁面會傳回Dispatcher
6. Dispatcher快取頁面
7. Dispatcher會將頁面傳回給瀏覽器
8. 如果再次請求相同頁面，則可直接從Dispatcher快取中提供該頁面，而無需在發佈執行個體上重新轉譯。 這樣可節省使用者和CPU週期在發佈執行個體上的等待時間。

我們在最後一節討論「頁面」。 但相同的配置也適用於其他資源，例如影像、CSS檔案、PDF下載等。

#### 如何快取資料

Dispatcher模組會利用託管Apache伺服器提供的設施。 HTML頁面、下載和圖片等資源會以簡單檔案形式儲存在Apache檔案系統中。 就是這麼簡單。

檔案名稱是由請求的資源的URL衍生而來。 如果您要求檔案 `/foo/bar.html` 例如儲存在/底下`var/cache/docroot/foo/bar.html`.

原則上，如果所有檔案都經過快取，並因而以靜態方式儲存在Dispatcher中，您可以提取Publish系統的外掛程式，而Dispatcher會作為簡單的網頁伺服器。 但這只是為了說明原則。 現實生活更複雜。 您不能快取所有內容，而且快取永遠不會完全「完整」，因為由於轉譯過程的動態性質，資源數量可能是無限的。 靜態檔案系統的模型有助於產生Dispatcher功能的粗略描述。 此外，它有助於說明Dispatcher的限制。

#### AEM URL結構與檔案系統對映

若要更詳細地瞭解Dispatcher，讓我們重新造訪簡單範例URL的結構。  讓我們來看下方的範例，

`http://domain.com/path/to/resource/pagename.selectors.html/path/suffix.ext?parameter=value&amp;otherparameter=value#fragment`

* `http` 代表通訊協定

* `domain.com` 是網域名稱

* `path/to/resource` 是資源儲存在CRX中以及隨後儲存在Apache伺服器的檔案系統中的路徑

從這裡開始，AEM檔案系統和Apache檔案系統之間有些許差異。

在AEM中，

* `pagename` 是資源標籤

* `selectors` 表示Sling中使用的多個選取器，以決定如何呈現資源。 URL可以有任意數量的選取器。 它們以句點分隔。 例如，選取器區段可能類似「french.mobile.fancy」。 選取器只能包含字母、數字和破折號。

* `html` 因為是最後一個「選取器」就稱為擴充功能。 在AEM/Sling中，它也部分決定轉譯指令碼。

* `path/suffix.ext` 是類似路徑的運算式，可以是URL的字尾。  它可用於AEM指令碼，以進一步控制資源的呈現方式。 我們稍後會提供此零件的完整章節。 目前，只要知道您可以將其用作其他引數就足夠了。 尾碼必須有副檔名。

* `?parameter=value&otherparameter=value` 是URL的查詢區段。 它可用來將任意引數傳遞至AEM。 無法快取具有引數的URL，因此引數應限制在絕對必要的情況下。

* `#fragment`，URL的片段部分不會傳遞至AEM，而只會用於瀏覽器；在JavaScript架構中會作為「路由引數」使用，或跳至頁面上的特定部分。

在Apache (*請參考下圖*)，

* `pagename.selectors.html` 會用作快取檔案系統中的檔案名稱。

如果URL有字尾 `path/suffix.ext` 然後，

* `pagename.selectors.html` 已建立為資料夾

* `path` 中的資料夾 `pagename.selectors.html` 資料夾

* `suffix.ext` 是中的檔案 `path` 資料夾。 注意：如果尾碼沒有副檔名，則不會快取檔案。

![從Dispatcher取得URL後的檔案系統配置](assets/chapter-1/filesystem-layout-urls-from-dispatcher.png)

*從Dispatcher取得URL後的檔案系統配置*

<br> 

#### 基本限制

URL、資源和檔案名稱之間的對應相當簡單。

不過，您可能會注意到一些陷阱，

1. URL可能會變得很長。 新增的「路徑」部分 `/docroot` 本機檔案系統上可能會輕易超過某些檔案系統的限制。 在Windows上的NTFS中執行Dispatcher可能會很困難。 不過，使用Linux是安全的。

2. URL可包含特殊字元和變音。 這通常不是Dispatcher的問題。 不過請記住，應用程式的許多位置都會解譯URL。 我們經常會看到應用程式的異常行為 — 只是為了找出一段很少使用的（自訂）程式碼未針對特殊字元進行徹底測試。 如果可以的話，您應該避免使用這兩項功能。 如果做不到，請規劃全面測試。

3. 在CRX中，資源具有子資源。 例如，一個頁面會有許多子頁面。 這在檔案系統中無法比對，因為檔案系統具有檔案或資料夾。

#### 不會快取沒有副檔名的URL

URL必須一律有副檔名。 不過您可以在AEM中提供沒有副檔名的URL。 這些URL將不會在Dispatcher中快取。

**範例**

`http://domain.com/home.html` 是 **可快取**

`http://domain.com/home` 是 **不可快取**

當URL包含尾碼時，適用相同的規則。 尾碼必須有擴充功能才能快取。

**範例**

`http://domain.com/home.html/path/suffix.html` 是 **可快取**

`http://domain.com/home.html/path/suffix` 是 **不可快取**

您可能會想，如果資源部分沒有副檔名，但尾碼有副檔名會發生什麼事？ 在此情況下，URL完全沒有尾碼。 檢視下一個範例：

**範例**

`http://domain.com/home/path/suffix.ext`

此 `/home/path/suffix` 是資源的路徑……因此URL中沒有尾碼。

**結論**

請一律將副檔名新增至路徑和後置字元。 瞭解SEO的人有時會辯稱，這會在搜尋結果中將您排在後面。 但是未快取的頁面速度會非常慢，而且會進一步下降。

#### 衝突的尾碼URL

假設您有兩個有效的URL

`http://domain.com/home.html`

和

`http://domain.com/home.html/suffix.html`

在AEM中絕對有效。 在本機開發電腦上，您不會看到任何問題（沒有Dispatcher）。 在UAT或負載測試中，您很可能也不會遇到任何問題。 我們面臨的問題非常微妙，以致於通過了大多數的測試。  當您處於尖峰時間，而且處理時間有限、可能沒有伺服器存取權，也沒有資源可加以修正時，就會受到嚴重影響。 我們曾經到過那裡……

那麼……有什麼問題嗎？

`home.html` 在檔案系統中，可以是檔案或資料夾。 並非兩者都與AEM中相同。

如果您要求 `home.html` 首先，會建立為檔案。

後續要求給 `home.html/suffix.html` 傳回有效結果，但以檔案形式 `home.html` 「封鎖」檔案系統中的位置，  `home.html` 無法第二次建立為資料夾，因此 `home.html/suffix.html` 不會快取。

![檔案系統中的檔案封鎖位置，無法快取子資源](assets/chapter-1/file-blocking-position-in-filesystem.png)

*檔案系統中的檔案封鎖位置，無法快取子資源*

<br> 

如果反過來，請先要求 `home.html/suffix.html` 則 `suffix.html` 已快取在資料夾下 `/home.html` 最初。 不過，此資料夾會被刪除並取代為檔案 `home.html` 當您後續要求時 `home.html` 作為資源。

![當父系擷取為資源時刪除路徑結構](assets/chapter-1/deleting-path-structure.png)

*當父系擷取為資源時刪除路徑結構*

<br> 

因此，快取的結果完全是隨機的，並取決於傳入請求的順序。 讓事情變得更棘手的是，您通常有多個傳送器。 而且效能、快取點選率和行為可能會因Dispatcher而異。 如果您想要瞭解網站無回應的原因，您必須確定檢視的是正確的Dispatcher和不幸的快取順序。 如果您檢視的Dispatcher幸運地擁有更有利的請求模式，您在嘗試尋找問題時將會遺失。

#### 避免衝突的URL

如果您對資源使用不同的副檔名，但您有尾碼，則可以避免「衝突的URL」，也就是資料夾名稱和檔案名稱會「競爭」檔案系統中的相同路徑。

**範例**

* `http://domain.com/home.html`

* `http://domain.com/home.dir/suffix.html`

兩者皆可完全快取，

![](assets/chapter-1/cacheable.png)

當您請求尾碼或完全避免使用尾碼時，請為資源選擇專用的擴充功能「dir」。 在極少數情況下，這些變數很有用。 而且可以輕鬆正確實施這些案例。  我們將在下一章中討論快取失效和排清時看到。

#### 不可快取的請求

讓我們檢閱最後一個章節的快速摘要，以及一些更多例外狀況。 如果URL設定為可快取，且為GET請求，則Dispatcher可以快取URL。 無法快取下列其中一個例外狀況。

**可快取的要求**

* 請求已設定為可在Dispatcher設定中快取
* 請求是普通的GET請求

**不可快取的請求或回應**

* 設定拒絕快取的要求（路徑、模式、MIME型別）
* 傳回「Dispatcher： no-cache」標頭的回應
* 傳回「Cache-Control： no-cache|private」標頭的回應
* 傳回「Pragma： no-cache」標頭的回應
* 使用查詢引數請求
* 沒有副檔名的URL
* 尾碼不含副檔名的URL
* 傳回200以外的狀態代碼的回應
* POST請求

## 讓快取失效並排清

### 概觀

最後一章列出了Dispatcher無法快取請求的大量例外狀況。 但您還需要考慮其他事項：只是因為Dispatcher _可以_ 快取要求，這並不一定意味著 _應該_.

重點是：快取通常很容易。 Dispatcher只需要儲存回應的結果，並在下次傳入非常相同的請求時傳回。 右? 錯誤！

難點在於 _失效_ 或 _排清_ 快取的。 Dispatcher需要知道資源何時已變更 — 並且需要再次呈現。

乍一看，這似乎是一項瑣碎的工作……但事實並非如此。 進一步瞭解，您將會發現單一和簡單資源以及依賴多個資源之高度網狀結構的頁面之間的一些棘手差異。

### 簡單資源與排清

我們已設定AEM系統，以便在收到特殊的「縮圖」選擇器的要求時，動態地為每個影像建立縮圖轉譯：

`/content/dam/path/to/image.thumb.png`

當然，我們也會提供URL，透過無選擇器URL提供原始影像：

`/content/dam/path/to/image.png`

如果我們同時下載縮圖和原始影像，最後的結果會是，

```
/var/cache/dispatcher/docroot/content/dam/path/to/image.thumb.png

/var/cache/dispatcher/docroot/content/dam/path/to/image.png
```

Dispatcher的檔案系統中。

現在，使用者會上傳並啟動該檔案的新版本。 系統會從AEM傳送失效請求給Dispatcher，

```
GET /invalidate
invalidate-path:  /content/dam/path/to/image

<no body>
```

讓無效變得容易：對Dispatcher上的特殊「/invalidate」 URL提出簡單的GET請求。 不需要HTTP-body，「payload」只是「invalidate-path」標頭。 另請注意，標頭中的invalidate-path是AEM知道的資源，而不是Dispatcher快取的檔案或檔案。 AEM只知道資源。 請求資源時，會在執行階段使用擴充功能、選取器和尾碼。 AEM不會針對資源上已使用的選取器執行任何簿記，因此在啟用資源時，資源路徑是唯一知道的資訊。

在我們的案例中這已經足夠。 如果資源已變更，我們可以安全地假設，該資源的所有轉譯也已變更。 在我們的範例中，如果影像已變更，也會轉譯新的縮圖。

Dispatcher可以安全地刪除資源，及其已快取的所有轉譯。 它會執行下列動作：

`$ rm /content/dam/path/to/image.*`

移除 `image.png` 和 `image.thumb.png` 以及所有其他符合該模式的轉譯。

只要您只使用一種資源來回應要求，就真的很簡單。

### 參照和網格化內容

#### 網格化內容問題

與上傳至AEM的影像或其他二進位檔案不同，HTML頁面不是孤立的動物。 它們以群居形式存在，而且透過超連結和參照彼此高度互連。 簡單的連結沒有害處，但當我們談論內容參考時，它會變得很棘手。 頁面上無處不在的頂端導覽或Teaser是內容參考。

#### 內容參考資料及其產生問題的原因

讓我們來看一個簡單的範例。 一家旅行社有一個宣傳加拿大之旅的網頁。 此促銷活動在其他兩個頁面的Teaser區段中都有介紹，在「首頁」和「冬季特惠」頁面上。

由於兩個頁面顯示相同的Teaser，因此不需要要求作者針對應顯示它的每個頁面多次建立Teaser。 相反地，目標頁面「加拿大」會在頁面屬性中保留一個區段，以便提供Teaser的相關資訊，或者最好提供完全呈現該Teaser的URL：

`<sling:include resource="/content/home/destinations/canada" addSelectors="teaser" />`

或

`<sling:include resource="/content/home/destinations/canada/jcr:content/teaser" />`

![](assets/chapter-1/content-references.png)

只有在AEM上才會像魅力一樣運作，但如果您在Publish執行個體上使用Dispatcher，會發生奇怪的情況。

想像一下，您已發佈您的網站。 您的加拿大頁面上的標題為「加拿大」。 當訪客要求您的首頁（有該頁面的Teaser參考）時，「加拿大」頁面上的元件會呈現類似以下內容

```
<div class="teaser">
  <h3>Canada</h3>
  <img …>
</div>
```

*到* 首頁。 首頁由Dispatcher儲存為靜態.html檔案，包括Teaser和其檔案中的標題。

現在，行銷人員瞭解到Teaser標題應該可行。 因此，他決定將標題從「Canada」變更為「Visit Canada」，並更新影像。

他發佈編輯過的「加拿大」頁面，並修訂先前發佈的首頁來檢視自己的變更。 但 — 沒有任何改變。 仍會顯示舊的Teaser。 他仔細檢視「冬季特惠」。 該頁面之前從未請求過，因此不會在Dispatcher中靜態快取。 因此，此頁面由Publish最新轉譯，現在包含新的「造訪加拿大」Teaser。

![Dispatcher會將過時的包含內容儲存在首頁中](assets/chapter-1/dispatcher-storing-stale-content.png)

*Dispatcher會將過時的包含內容儲存在首頁中*

<br> 

發生了什麼事？ Dispatcher會儲存靜態版本的頁面，其中包含轉譯時從其他資源提取的所有內容和標籤。

Dispatcher只是檔案系統式的網頁伺服器，速度很快，但相對簡單。 如果包含的資源變更，則不會意識到這一點。 它仍會依附於轉譯包含頁面時存在的內容。

「冬季特殊優惠」頁面尚未轉譯，因此Dispatcher上沒有靜態版本，因此在請求時全新轉譯時隨新Teaser一起顯示。

您可能會認為，當資源變更時，Dispatcher在轉譯和清除已使用此資源的所有頁面時會追蹤到它觸及的每個資源。 但Dispatcher不會轉譯頁面。 轉譯是由Publish系統執行。 Dispatcher不知道哪些資源會進入轉譯的.html檔案。

還是不相信？ 您可能會認為 *「必須有實作某種相依性追蹤的方法」*. 確實有，或者更準確地說 *為*. 公報3：AEM的曾曾祖父有一個相依性追蹤器在 _工作階段_ 用於呈現頁面的屬性。

在請求期間，透過此工作階段取得的每個資源都會作為目前呈現之URL的相依性受到追蹤。

但事實證明，追蹤相依性非常昂貴。 人們很快就發現，如果他們完全關閉相依性追蹤功能，並依賴在一個html頁面變更後重新呈現所有html頁面，網站就會更快。 此外，這個方案也不完美 — 過程中會出現許多陷阱和例外。 在某些情況下，您未使用請求預設工作階段來取得資源，而是使用管理員工作階段來取得一些協助程式資源來轉譯請求。 這些相依性通常不會被追蹤，並導致作業團隊要求手動清除快取的頭痛和電話呼叫。 如果他們有標準程式，你很幸運。 途中還有更多疑問，但……讓我們停止回憶。 這可以追溯到2005年。 最後，該功能預設為在Communication 4中停用，並且它沒有重新成為後繼的CQ5，後者後來成為AEM。

### 自動失效

#### 完全排清比相依性追蹤便宜時

由於CQ5，我們完全依賴讓整個網站失效（或多或少地），只要其中一個頁面變更。 此功能稱為「自動失效」。

但同樣地，丟棄和轉譯數百個頁面會比執行適當的相依性追蹤和部分轉譯來得便宜，怎麼可能呢？

主要原因有二：

1. 平均而言，網站僅會經常要求一小部分頁面。 因此，即使您捨棄所有演算後的內容，之後也只會立即請求數十個內容。 呈現頁面的長尾可以在實際請求時隨著時間分發。 因此，實際上轉譯頁面上的負載並不如您預期般高。 當然，總是會有例外……我們稍後會討論一些有關如何處理大型網站上具有空Dispatcher快取的均勻分佈負載的技巧。

2. 所有頁面仍由主導覽進行連線。 因此，幾乎所有頁面最終都彼此相依。 這表示即使是最聰明的相依性追蹤器也會找出我們所知道的：如果其中一個頁面變更，您必須使所有其他頁面失效。

你不相信？ 讓我們來說明最後一點。

我們使用與上一個範例相同的引數，搭配Teaser參考遠端頁面的內容。 直到現在，我們才使用更極端的範例：自動演算的主導覽。 和Teaser一樣，導覽標題是從連結或「遠端」頁面中繪製的，作為內容參考。 遠端導覽標題不會儲存在目前轉譯的頁面中。 您應記住，導覽會呈現在網站中的每一頁上。 因此，在有主要導覽的所有頁面上，都會反複使用一個頁面的標題。 此外，如果您想要變更導覽標題，您只想在遠端頁面上執行一次，而不是在每個參考頁面的每個頁面上執行。

因此，在我們的範例中，導覽會使用目標頁面的「NavTitle」在導覽中呈現名稱，將所有頁面網格化。 「冰島」的導覽標題取自「冰島」頁面，並演算至每個具有主要導覽的頁面。

![主要導覽透過提取頁面的「NavTitles」，不可避免地將所有頁面的內容分割在一起](assets/chapter-1/nav-titles.png)

*主要導覽透過提取頁面的「NavTitles」，不可避免地將所有頁面的內容分割在一起*

<br> 

如果您將Iceline頁面上的NavTitle從「Iceline」變更為「Beautiful Iceline」，該標題會立即在所有其他頁面主功能表上變更。 因此，在該變更之前呈現和快取的頁面都會變得陳舊並需要失效。

#### 自動失效的實作方式： .stat檔案

現在，如果您有一個包含數千個頁面的大型網站，則需要相當長的時間來重複瀏覽所有頁面並實際刪除它們。 在此期間，Dispatcher可能會無意中提供過時內容。 更糟糕的是，存取快取檔案時可能會發生一些衝突，可能是某個頁面剛刪除時被請求，或該頁面由於後續立即啟用後發生的第二次失效而再次被刪除。 想想會有多亂吧。 幸好事情不是這樣的。 Dispatcher使用巧妙的技巧來避免這種情況：它不會刪除數百和數千個檔案，而是在檔案發佈時將一個簡單的空白檔案放入檔案系統的根目錄中，因此所有從屬檔案都被視為無效。 此檔案稱為「statfile」。 statfile是空白檔案 — 與statfile有關的重要是其建立日期。

Dispatcher中所有建立日期早於statfile的檔案，都已在上次啟動（和失效）前演算，因此會視為「無效」。 它們仍然實際存在於檔案系統中，但Dispatcher會忽略它們。 它們「過時」。 每當發出對過時資源的請求時，Dispatcher都會要求AEM系統重新呈現頁面。 然後，新轉譯的頁面會儲存在檔案系統中 — 現在會有一個新的建立日期，而且會再次重新整理。

![.stat檔案的建立日期會定義哪些內容已過時以及哪些內容是最新狀態](assets/chapter-1/creation-date.png)

*.stat檔案的建立日期會定義哪些內容已過時以及哪些內容是最新狀態*

<br> 

您可能會問，為何將其稱為「.stat」？ 也可能不是「.invalidated」？ 嗯，您可以想像，在檔案系統中擁有該檔案有助於Dispatcher判斷哪些資源可以 *靜態* 服務 — 就像從靜態Web伺服器一樣。 這些檔案不再需要動態呈現。

然而，這個名稱的真正性質並非比喻性。 它衍生自Unix系統呼叫 `stat()`，會傳回檔案的修改時間（以及其他屬性）。

#### 混合使用簡單與自動驗證

但請稍候……先前我們說過，單一資源會遭到實體刪除。 現在我們說，在Dispatcher眼中，較新的statfile實際上會讓這些檔案失效。 為什麼要先進行實體刪除？

答案很簡單。 您通常會同時使用這兩種策略，但用於不同的資源。 二進位資產（例如影像）是獨立的。 它們未連線至其他資源，因此需要呈現其資訊。

另一方面，HTML頁面具有高度相依性。 因此，您可以對這些應用自動失效。 這是Dispatcher中的預設設定。 屬於失效資源的所有檔案都會被實際刪除。 此外，結尾為&quot;。html&quot;的檔案會自動失效。

Dispatcher會根據副檔名來決定是否套用自動失效配置。

可設定自動失效的檔案結尾。 理論上，您可以包含自動失效的所有擴充功能。 但請記住，這需要付出高昂的代價。 您不會看到過時資源無意間傳送，但傳送效能會因過度失效而大幅降低。

舉例來說，假設您實作一個方案，以動態方式呈現PNG和JPG，並依賴其他資源來執行此操作。 您可能想要將高解析度影像重新調整為較小的網頁相容解析度。 當您這樣做時，也會變更壓縮率。 此範例中的解析度和壓縮率不是固定的常數，而是使用影像的元件中可設定的引數。 現在，如果變更此引數，您必須讓影像失效。

沒問題 — 我們剛才瞭解到，我們可以新增影像到自動失效，並且每當任何變更時，都隨時可以重新演算影像。

#### 用浴水扔掉嬰兒

沒錯，這是個大問題。 請再次閱讀最後一段。 「……每當任何變更時，都會以全新方式呈現影像。」 如你所知，一個好網站會不斷改變；在這裡新增內容、在那裡更正錯字、在其他地方調整Teaser。 這表示您的所有影像都會持續失效，且需要重新演算。 不要低估這一點。 在本機開發電腦上，以毫秒為單位動態呈現和傳輸影像資料的運作方式。 您的生產環境需要以每秒100倍的頻率執行此操作。

讓我們在此澄清一下，當html頁面變更時，您的jpg需要重新呈現，反之亦然。 只有一個「貯體」的檔案可自動失效。 會整體排清。 無需進一步細分詳細結構。

根據預設，自動失效保留為「.html」是有充分理由的。 目標是儘可能縮小該貯體。 不要為了安全起見，就為了讓一切失效，而把嬰兒和洗澡水一起扔掉。

應該在該資源的路徑中提供獨立資源。 這有助於讓系統失效。 簡單明瞭，請勿建立對應配置，例如「資源/a/b/c」是從「/x/y/z」提供的。 讓您的元件使用預設的Dispatcher自動失效設定。 請勿嘗試在Dispatcher中修復設計不良且過度失效的元件。

##### 自動失效的例外：ResourceOnly失效

Dispatcher的失效請求通常是由復寫代理程式從發佈系統觸發。

如果您對相依性感到非常自信，可以嘗試建立自己的失效復寫代理程式。

本指南會提供一些詳細資訊，但我們希望您至少有一些提示。

1. 非常清楚您正在做什麼。 正確取得失效權真的很難。 這就是自動失效如此嚴格的原因之一；這是為了避免傳送過時內容。

2. 如果您的代理程式傳送HTTP標頭 `CQ-Action-Scope: ResourceOnly`，這表示此單一失效請求不會觸發自動失效。 這個( [https://github.com/cqsupport/webinar-dispatchercache/tree/master/src/refetching-flush-agent/refetch-bundle](https://github.com/cqsupport/webinar-dispatchercache/tree/master/src/refetching-flush-agent/refetch-bundle))程式碼片段可能是您自己的復寫代理程式的良好起點。

3. `ResourceOnly`，只會防止自動失效。 若要實際執行必要的相依性解析和無效化，您必須自行觸發無效化請求。 您可能想要檢查套件Dispatcher排清規則([https://adobe-consulting-services.github.io/acs-aem-commons/features/dispatcher-flush-rules/index.html](https://adobe-consulting-services.github.io/acs-aem-commons/features/dispatcher-flush-rules/index.html))，以獲得實際發生的靈感。

我們不建議您建立相依性解決配置。 只是投入太多卻收效甚微 — 就像之前所說，有太多事情會出錯。

而是應該找出哪些資源對其他資源沒有任何相依性，並且可以在不自動失效的情況下失效。 不過，您不需要就此使用自訂復寫代理程式。 只需在您的Dispatcher設定中建立自訂規則，從自動失效中排除這些資源。

我們說主要導覽或Teaser是相依性的來源。  — 如果您以非同步方式載入導覽和Teaser，或在Apache中以SSI指令碼加入它們，您將沒有要追蹤的相依性。 當我們討論「Sling Dynamic Include」時，我們將在本檔案後面詳細介紹非同步載入元件。

這同樣適用於快顯視窗或載入燈箱的內容。 這些片段也很少有導覽（亦即「相依性」），並且可以作為單一資源失效。

## 以Dispatcher建立元件

### 在真實世界範例中套用Dispatcher機制

在最後一章中，我們說明了Dispatcher的基本機制、其一般運作方式及其限制。

我們現在想要將這些機制套用至您很可能可以在專案要求中找到的一類元件。 我們特意挑選元件，以展示您遲早也會遇到的問題。 不用擔心，並非所有元件都需要如此多的考量。 但是，如果您認為必須建立這類元件，您即充分瞭解其後果並知道如何處理。

### 多工緩衝處理元件（反向）模式

#### 回應式影像元件

讓我們來說明具有互連二進位檔之元件的共同模式（或反模式）。 我們將為「回應式影像」建立元件「respi」。 此元件應該能夠將顯示影像調整至其所顯示的裝置。 在桌上型電腦和平板電腦上，它會顯示影像的完整解析度；在手機上，它會顯示裁切範圍較窄的較小版本，甚至是完全不同的主題（在回應式世界中，這稱為「藝術方向」）。

資產只會上傳至AEM的DAM區域 _已引用_ 在回應式影像元件中。

respi-component會負責轉譯標籤及傳遞二進位影像資料。

我們在這裡實作的方式是我們在許多專案中看到的常見模式，即使其中一個AEM核心元件也是以該模式為基礎。 因此，身為開發人員的您很有可能調整該模式。 在封裝方面有其優點，但需要付出大量努力才能使其為Dispatcher做好準備。 我們稍後會討論幾個如何緩解問題的選項。

我們將此處使用的模式稱為「多工緩衝處理器模式」，因為問題可追溯到Communication 3的早期，當時有一個方法「多工緩衝處理器」，可呼叫資源以將其二進位原始資料串流到回應中。

原始術語「多工緩衝處理」實際上是指共用的慢速離線周邊裝置，例如印表機，因此在這裡無法正確套用。 不過我們還是喜歡這個詞，因為它很少在網路上被區分。 而且每個模式都應該有一個可區別的名稱，對嗎？ 您可以自行決定這是模式還是反模式。

#### 實施

以下是實施回應式影像元件的方式：

元件有兩個部分；第一部分呈現影像的HTML標籤，第二部分將參照影像的二進位資料「卷軸」。 由於這是回應式設計的現代網站，因此我們呈現的並非簡單 `<img src"…">` 標籤，但中的一組影像 `<picture/>` 標籤之間。 我們會為每個裝置上傳兩個不同的影像至DAM，並從影像元件中參照它們。

元件有三個轉譯指令碼（實作於JSP、HTL或作為servlet），每個都透過專用選擇器定址：

1. `/respi.jsp`  — 沒有選擇器可呈現HTML標籤
2. `/respi.img.java` 以轉譯案頭版本
3. `/respi.img.mobile.java` 以轉譯行動版本。


元件會放置在首頁的parsys中。 CRX中產生的結構如下圖所示。

![CRX中回應式影像的資源結構](assets/chapter-1/responsive-image-crx.png)

*CRX中回應式影像的資源結構*

<br> 

元件標籤會如此呈現，

```plain
  #GET /content/home.html

  <html>

  …

  <div class="responsive-image>

  <picture>
    <source src="/content/home/jcr:content/par/respi.img.mobile.jpg" …/>
    <source src="/content/home/jcr:content/par/respi.img.jpg …/>

    …

  </picture>
  </div>
  …
```

而且……我們完成了精心封裝的元件。

#### 有回應的影像元件在運作中

現在，使用者透過Dispatcher請求頁面 — 和資產。 這會導致Dispatcher檔案系統中的檔案，如下所示：

![封裝回應式影像元件的快取結構](assets/chapter-1/cached-structure-encapsulated-image-comonent.png)

*封裝回應式影像元件的快取結構*

<br> 

考慮使用者將兩個花朵影像的新版本上傳並啟動到DAM。 AEM將根據以下專案的失效請求傳送：

`/content/dam/flower.jpg`

和

`/content/dam/flower-mobile.jpg`

到Dispatcher。 不過，這些請求都白費了。 內容已快取為元件子結構下的檔案。 這些檔案現已過時，但仍會應要求提供服務。

![結構不符導致內容過時](assets/chapter-1/structure-mismatch.png)

*結構不符導致內容過時*

<br> 

此方法還有另一個考量。 假設您在多個頁面上使用相同的flower.jpg。 然後您會在多個URL或檔案下快取相同的資產，

```
/content/home/products/jcr:content/par/respi.img.jpg

/content/home/offers/jcr:content/par/respi.img.jpg

/content/home/specials/jcr:content/par/respi.img.jpg

…
```

每次請求新的和未快取的頁面時，都會以不同的URL從AEM擷取資產。 沒有Dispatcher快取和瀏覽器快取可以加速傳送。

#### 多工緩衝處理器圖樣發光的位置

有一個自然的例外情況，此模式甚至其簡單形式也很有用：如果二進位檔儲存在元件本身中，而不是儲存在DAM中。 不過，這僅適用於網站上使用一次的影像，且不會將資產儲存在DAM中，表示您難以管理資產。 想象一下，您針對特定資產的使用授權會用完。 如何找出您使用資產的元件？

看到沒？ DAM中的「M」代表「管理」，就像在數位資產管理中一樣。 您不想放棄此功能。

#### 結論

從AEM開發人員的角度來看，這個模式看起來非常優雅。 但是，將Dispatcher納入方程式後，您可能會同意，天真的方法可能不夠。

目前由您來決定這是模式還是反模式。 或許您已經有一些好主意，想要緩解上述問題？ 很好。 您應該很想知道其他專案如何解決這些問題。

### 解決常見的Dispatcher問題

#### 概觀

讓我們討論一下如何更適合快取記憶體使用。 有幾個選項。 有時候，您無法選擇最佳解決方案。 也許您進入的專案已經在執行中，而您僅有有限的預算可以修正手頭的「快取問題」，卻不足以進行完整的重構。 或是您遇到比範例影像元件更複雜的問題。

我們將在以下各節中概述其原理和注意事項。

同樣地，這是根據實際體驗而定。 我們已在野外看到所有這些模式，因此這不是學術練習。 這就是為什麼我們會向您顯示一些反模式，以便您有機會從其他人已經犯過的錯誤中學習。

#### 快取殺手

>[!WARNING]
>
>這是反模式。 請勿使用。 永遠。

您是否曾見過類似以下的查詢引數 `?ck=398547283745`？ 這類檔案稱為cache-killer (&quot;ck&quot;)。 其想法是，如果您新增任何查詢引數，將不會快取資源。 此外，如果您新增隨機數字作為引數的值(例如「398547283745」)，URL就會變得唯一，而且您會確定AEM系統和熒幕之間的其他任何快取也無法快取。 通常中間嫌疑犯會是位於Dispatcher前方的「清漆」快取、CDN甚至瀏覽器快取。 再次強調：請勿這麼做。 您確實希望儘可能長時間地快取資源。 快取是您的朋友。 不要殺朋友。

#### 自動失效

>[!WARNING]
>
>這是反模式。 請避免用於數位資產。 嘗試保留Dispatcher的預設設定，這只會讓>自動讓「.html」檔案失效

您可以在短期內將「.jpg」和「.png」新增到Dispatcher中的自動失效設定。 這表示每當發生失效，所有「.jpg」、「.png」和「.html」都需要重新呈現。

如果企業主抱怨未看到變更在即時網站上以足夠快的速度實現，則此模式非常容易實施。 但這只能讓您花點時間想出更複雜的解決方案。

請務必瞭解對效能的巨大影響。 這會顯著降低網站的速度，甚至可能影響穩定性（如果您的網站是經常變更的高負載網站），例如新聞入口網站。

#### URL指紋

URL指紋看起來像是快取殺手。 但事實並非如此。 它不是隨機數字，而是資源內容的特性值。 這可以是資源內容的雜湊，也可以是上傳、編輯或更新資源時的時間戳記（更簡單）。

Unix時間戳記適合在真實世界中實作。 為了達到更好的可讀性，在本教學課程中，我們使用更易讀的格式： `2018 31.12 23:59 or fp-2018-31-12-23-59`.

指紋不得作為查詢引數使用，因為無法快取具有查詢引數的URL。 您可以使用指紋的選擇器或尾碼。

假設，檔案 `/content/dam/flower.jpg` 具有 `jcr:lastModified` 2018年12月31日日期，23:59。 具有指紋的URL是 `/content/home/jcr:content/par/respi.fp-2018-31-12-23-59.jpg`.

只要參照的資源(`flower.jpg`)檔案未變更。 因此可以無限期地快取，而且它不是快取殺手。

請注意，此URL需要由回應式影像元件建立及服務。 這不是現成可用的AEM功能。

這是基本概念。 不過，有一些細節可能很容易被忽略。

在我們的範例中，元件在23:59完成轉譯和快取。 現在影像已變更，假設00:00。  元件 _會_ 在其標籤中產生新的指紋URL。

您可能會認為 _應該_...但事實並非如此。由於只變更了影像的二進位檔並且未觸及包含頁面，因此不需要重新轉譯HTML標籤。 因此，Dispatcher會以舊指紋提供頁面，進而提供舊版本的影像。

![影像元件比參照的影像更新，未演算全新的指紋。](assets/chapter-1/recent-image-component.png)

*影像元件比參照的影像更新，未演算全新的指紋。*

<br> 

現在，如果您重新啟用首頁（或該網站的任何其他頁面），statfile將會更新，Dispatcher會考慮home.html過時，並在影像元件中使用新指紋重新演算它。

但我們沒有啟用首頁，對嗎？ 為什麼我們要啟用一個我們仍然未觸及的頁面？ 此外，我們可能沒有足夠的許可權來啟用頁面，或是核准工作流程耗時太長，我們根本無法在短時間內完成工作。 那麼 — 該怎麼辦？

#### 懶惰的管理工具 — 降低Statfile層級

>[!WARNING]
>
>這是反模式。 請僅在短期內使用，以爭取一些時間，並想出更複雜的解決方案。

懶惰的管理員通常會「_將自動失效設定為jpgs，並將statfile層級設定為零，這始終有助於解決各種型別的快取問題_.」 您會在技術論壇中找到該建議，並有助於解決您的失效問題。

到目前為止，我們尚未討論statfile層級。 基本上，自動失效僅適用於相同子樹狀結構中的檔案。 但問題是頁面和資產通常不位於相同的子樹狀結構中。 頁面位於以下某個位置 `/content/mysite` 而資產位在底下 `/content/dam`.

「statfile層級」會定義子樹狀結構的根節點深度。 在上述範例中，層級將是「2」(1=/content， 2=/mysite，dam)

將statfile層級「降低」為0的想法基本上是將整個/content樹狀結構定義為唯一的子樹狀結構，以使頁面和資產存在於相同的自動失效網域中。 因此我們只會在層級的大樹上（在docroot &quot;/&quot;）。 但只要發佈某些內容，就會自動讓伺服器上的所有網站失效，即使在完全不相關的網站上也是如此。 相信我們：長遠來看，這不是個好主意，因為您會嚴重降低整體的快取命中率。 您所能做的就是希望AEM伺服器有足夠的火力，可以在沒有快取的情況下執行。

稍後您將瞭解更深入的statfile層級的完整優點。

#### 實作自訂失效代理程式

無論如何 — 我們需要告訴Dispatcher如果「.jpg」或「.png」變更為允許使用全新URL重新呈現，就可以使HTML頁面失效。

例如，我們在專案中看到的是發佈系統上的特殊復寫代理，每當發佈網站的影像時，就會傳送該網站的失效請求。

如果您可透過命名慣例從資產的路徑衍生出網站的路徑，這會很有幫助。

一般而言，最好將網站和資產路徑配對，如下所示：

**範例**

```
/content/dam/site-a
/content/dam/site-b

/content/site-a
/content/site-b
```

如此一來，當您的自訂Dispatcher清除代理程式遇到對的變更時，可以輕鬆傳送和使/content/site-a失效請求。 `/content/dam/site-a`.

事實上，您告訴Dispatcher讓哪個路徑失效並不重要，只要它位於相同網站、相同「子樹」中。 您甚至不必使用真正的資源路徑。 它也可以是「虛擬」的：

```
GET /dispatcher-invalidate
Invalidate-path /content/mysite/dummy
```

![](assets/chapter-1/resource-path.png)

1. 當DAM中的檔案變更時，會觸發發佈系統上的接聽程式

2. 接聽程式傳送失效請求給Dispatcher。 由於自動失效，我們會在自動失效中傳送哪個路徑並不重要，除非該路徑位於網站首頁下 — 或在網站statfile層級中更精確。

3. statfile已更新。

4. 下次請求首頁時，將會重新呈現。 新的指紋/日期會從影像的lastModified屬性中取得，作為額外的選取器

5. 這會隱含地建立新影像的參照

6. 如果實際請求影像，則會建立新轉譯並儲存在Dispatcher中


#### 清理的必要性

噢。 已完成. 萬歲！

嗯……還不是很清楚。

路徑，

`/content/mysite/home/jcr:content/par/respi.img.fp-2018-31-12-23-59.jpg`

與任何失效的資源無關。 記憶? 我們只會使「虛擬」資源失效，並依賴自動失效將「home」視為無效。 影像本身可能永遠不會 _實際_ 已刪除。 因此，快取將會成長與成長。 當影像變更並啟動時，會在Dispatcher的檔案系統中取得新檔案名稱。

未實際刪除快取檔案並無限期保留這些檔案有三個問題：

1. 很明顯您浪費了儲存容量。 同意 — 儲存裝置在過去幾年已變得更便宜。 但是影像解析度和檔案大小在過去幾年也有所增長，因為有了類似視網膜的顯示器，這些顯示器渴望清晰銳利的影像。

2. 即使硬碟變得更便宜，「儲存」可能也不會變得更便宜。 我們看到一種趨勢，即您的資料中心供應商不使用（廉價）裸機硬碟儲存裝置，而是在NAS上租用虛擬儲存裝置。 這類儲存裝置更可靠、可擴充，但價格也更高。 您可能不想藉由儲存過時的垃圾而浪費這些資源。 這不僅與主要儲存裝置有關，備份亦是如此。 如果您有現成的備份解決方案，則可能無法排除快取目錄。 最後，您也會備份垃圾資料。

3. 更糟糕的是：您可能只購買過一段有限時間用於特定影像的使用授權 — 只要您需要這些授權即可。 現在，如果您在授權過期後仍儲存影像，可能會被視為侵犯版權。 您可能無法再在網頁中使用影像，但Google仍可找到。

最後，您會想出一些清潔室員的辦法，來清理所有早於……的檔案，讓這種亂丟垃圾的情況維持在可控範圍內，假設一週時間。

#### 濫用URL指紋進行拒絕服務攻擊

但請稍等，此解決方案中還有另一個缺陷：

我們有些濫用選取器作為引數： fp-2018-31-12-23-59是以「cache-killer」的形式動態產生的。 但可能是某個無聊的孩子（或某個已經瘋狂的搜尋引擎編目程式）開始請求這些頁面：

```
/content/mysite/home/jcr:content/par/img.fp-0000-00-00-00-00.jpg
/content/mysite/home/jcr:content/par/img.fp-0000-00-00-00-01.jpg
/content/mysite/home/jcr:content/par/img.fp-0000-00-00-00-02.jpg

…
```

每個請求都會略過Dispatcher，造成發佈執行個體上的負載。 更糟糕的是，在Dispatcher上建立相符的檔案。

因此……您必須檢查影像的jcr：lastModified日期，如果不是預期的日期，則傳回404，而不是只使用指紋當作簡單的快取殺手。 這需要一些時間和CPU週期……這是您一開始想要防止的。

#### 高頻發行中的URL指紋警告

您不僅可以將指紋架構用於來自DAM的資產，還可以用於JS和CSS檔案及相關資源。

[已建立版本的Clientlibs](https://adobe-consulting-services.github.io/acs-aem-commons/features/versioned-clientlibs/index.html) 是使用此方法的模組。

但在這裡，您可能會面臨另一個警告：具有URL指紋：它會將URL連結至內容。 您不變更URL就無法變更內容（亦即，更新修改日期）。 這是指紋最初的設計目的。 但請考量一下，您正在推出新版本，其中包含新的CSS和JS檔案，以及帶有新指紋的新URL。 您的所有HTML頁面仍會參照舊的指紋URL。 因此，為了讓新版本持續運作，您需要一次讓所有HTML頁面失效，以強制使用對新指紋檔案的參照重新呈現。 如果您有多個網站仰賴相同的程式庫，這可能需要大量重新呈現 — 在這裡，您無法運用 `statfiles`. 因此，請準備好在轉出後檢視發佈系統上的負載尖峰。 您可能會考慮使用具有快取預熱功能的藍綠色部署，或是在您的Dispatcher前面使用TTL型快取……可能性是無限的。

#### 簡短插播

哇 — 這有很多細節需要考慮，對嗎？ 而且不易理解、測試及除錯。 所有這一切都是為了看似優雅的解決方案。 無可否認，這確實很優雅，但只是從僅限AEM的角度來看。 它與Dispatcher一起變得很麻煩。

不過，這並不能解決一個基本警告，如果影像在不同頁面上多次使用，則會在這些頁面下快取。 沒有太多快取協同效應。

一般來說，URL指紋識別是工具包中不錯的工具，但您需要小心地套用，因為這樣可能會導致新問題，而只能解決幾個現有的問題。

所以……那是一個很長的章節。 但我們經常看到這個模式，覺得有必要為您呈現全貌，包含所有優點與缺點。 URL指紋解決了多工緩衝處理器模式的一些固有問題，但實作工作量相當大，您也需要考慮其他（更簡單的）解決方案。 我們的建議是務必檢查您是否可將URL根據提供的資源路徑設定且沒有中繼元件。 我們將在下一章中討論此內容。

##### 執行階段相依性解析

執行階段相依性解析是我們一直在一個專案中考慮的概念。 但經過思考後，變得相當複雜，因此我們決定不再實施。

基本概念如下：

Dispatcher不知道資源的相依性。 這只不過是一棧沒有多少語意的單一檔案。

AEM對相依性也一無所知。 它缺乏適當的語意或「相依性追蹤器」。

AEM知道一些參考資料。 當您嘗試刪除或移動參照的頁面或資產時，系統會利用此知識發出警告。 方法是刪除資產時查詢內部搜尋。 內容參考確實有非常特殊的形式。 它們是以「/content」開頭的路徑運算式。 因此，它們可以輕鬆建立全文檢索索引，並在必要時進行查詢。

在我們的案例中，我們需要Publish系統上的自訂復寫代理程式，當路徑變更時，它會觸發搜尋特定路徑。

假設

`/content/dam/flower.jpg`

發佈時已變更。 代理程式會引發「/content/dam/flower.jpg」搜尋，並尋找所有參照這些影像的頁面。

然後，它可能會向Dispatcher發出許多失效請求。 每個包含資產的頁面各一個。

理論上，這應該有效。 但只適用於第一層級相依性。 例如，當您在頁面上使用的體驗片段上使用影像時，您不想要將該配置套用至多層級相依性。 事實上，我們認為方法太複雜，而且可能會出現執行階段問題。 一般來說，最佳建議是不要在事件處理常式中進行昂貴的運算。 尤其是搜尋可能會變得相當昂貴。

##### 結論

我們希望我們已徹底討論多工緩衝處理器模式，能協助您決定要在何時使用，而不是在您的實作中使用。

## 避免Dispatcher問題

### 以資源為基礎的URL

解決相依性問題的更優雅方法是完全沒有相依性。 避免使用某個資源僅代理另一個資源時產生的人工相依性，如同我們在最後一個範例中所做的那樣。 儘量將資源視為「孤立」實體。

我們的範例很容易解決：

![使用繫結至影像的servlet （而非元件）來多工緩衝影像。](assets/chapter-1/spooling-image.png)

*使用繫結至影像的servlet （而非元件）來多工緩衝影像。*

<br> 

我們使用資產原始資源路徑來呈現資料。 如果需要依原樣轉譯原始影像，我們可以使用資產的AEM預設轉譯器。

如果需要對特定元件進行某些特殊處理，我們會在該路徑上註冊一個專用的servlet並選擇器以代表元件進行轉換。 我們以「.respi」為典範。 選擇器。 建議您持續追蹤全域URL空間中使用的選取器名稱(例如 `/content/dam`)且具有良好的命名慣例以避免命名衝突。

順便一提，我們看不出任何程式碼一致性問題。 此servlet可與元件sling模型在同一Java套件中定義。

我們甚至可以在全域空間中使用其他選擇器，例如

`/content/dam/flower.respi.thumbnail.jpg`

很簡單，對吧？ 那為什麼人們會想出像多工緩衝處理器這樣的複雜模式？

嗯，我們可以解決避免內部內容參照的問題，因為外部元件在呈現內部資源時幾乎沒有增加值或資訊，可以輕鬆地以一組靜態選取器編碼，控制單一資源的表示。

但有一類案例是無法透過資源型URL輕鬆解決的。 我們將這種型別的情況稱為「引數注入元件」，並在下一章中討論。

### 引數注入元件

#### 概觀

最後一個章節中的多工緩衝處理器只是資源周圍的精簡包裝函式。 它帶來的麻煩比解決問題還要多。

我們可以使用簡單的選擇器輕鬆替代該包裝，並新增相應的servlet來服務這類請求。

但如果「respi」元件不只是Proxy，該怎麼辦？ 如果元件真正有助於元件轉譯，該怎麼辦？

讓我們介紹一下「respi」元件的小擴充功能，這有點改變遊戲規則。 我們再次介紹一些天真的解決方案，以應付新的挑戰，並展示其不足之處。

#### Respi2元件

respi2元件是顯示回應式影像的元件，其本身即為回應式元件。 但是它有一個小小的附加元件，

![CRX結構：respi2元件將品質屬性新增至傳遞](assets/chapter-1/respi2.png)

*CRX結構：respi2元件將品質屬性新增至傳遞*

<br> 

影像為jpeg，且可以壓縮jpeg。 壓縮jpeg影像時，您會交換檔案大小的品質。 壓縮的定義為範圍從「1」到「100」的數值「品質」引數。 「1」表示「小但低品質」，「100」表示「高品質但大檔案」。 那麼，哪一個是理想的價值呢？

和所有IT事務一樣，答案是：「取決於。」

在此，它取決於基序。 具有高對比邊緣的圖案，例如圖案，包括書面的文字、建築的像片、插圖、產品方塊的草圖或像片（具有銳利的輪廓和文字），通常都屬於該類別。 具有更柔和色彩與對比轉變的圖案（如風景或肖像），可以稍微壓縮一點，而不會失去可見的品質。 自然攝影通常屬於這個類別。

此外，根據影像的使用位置，您可能要使用不同的引數。 Teaser中的小型縮圖可能會比全熒幕主圖橫幅中使用的相同影像承受更好的壓縮。 這表示，品質引數並非與影像天生相關，而是與影像和內容相關。 而且符合作者的口味。

簡而言之：沒有適用於所有圖片的完美設定。 沒有萬能的。 最好由作者決定。 他將會調整「品質」引數做為元件中的屬性，直到滿意品質且不會進一步犧牲頻寬為止。

DAM中現在提供二進位檔案，以及提供高品質屬性的元件。 URL應該是什麼樣子？ 哪個元件負責多工緩衝處理？

#### 天真的方法1：傳遞屬性作為查詢引數

>[!WARNING]
>
>這是反模式。 請勿使用。

在上一章，元件轉譯的影像URL看起來像這樣：

`/content/dam/flower.respi.jpg`

唯一缺少的就是品質值。 元件知道作者輸入了哪個屬性……當轉譯標籤時（例如），它很容易地作為查詢引數傳遞給影像轉譯servlet `flower.respi2.jpg?quality=60`：

```plain
  <div class="respi2">
  <picture>
    <source src="/content/dam/flower.respi2.jpg?quality=60" …/>
    …
  </picture>
  </div>
  …
```

這不是個好主意。 記憶? 無法快取包含查詢引數的請求。

#### 天真的方法2：傳遞其他資訊作為選擇器

>[!WARNING]
>
>這可能會變成反模式。 請謹慎使用。

![將元件屬性傳遞為選取器](assets/chapter-1/passing-component-properties.png)

*將元件屬性傳遞為選取器*

<br> 

這是上一個URL的細微變化。 只有這次我們使用選取器將屬性傳遞至servlet，以便可快取結果：

`/content/dam/flower.respi.q-60.jpg`

這個更好，但還記得最後一個章節中那個尋找此類模式的討厭的指令碼小孩嗎？ 他能看到在值上循環可以走多遠：

```plain
  /content/dam/flower.respi.q-60.jpg
  /content/dam/flower.respi.q-61.jpg
  /content/dam/flower.respi.q-62.jpg
  /content/dam/flower.respi.q-63.jpg
  …
```

這再次略過快取並在發佈系統上建立負載。 因此，這可能不是個好主意。 您可以僅篩選一小部分引數來緩解此問題。 您只想允許 `q-20, q-40, q-60, q-80, q-100`.

#### 使用選取器時篩選無效請求

減少選擇器的數量是個不錯的開端。 根據經驗法則，您應一律將有效引數的數量限製為絕對最小值。 如果您聰明地這樣做，您甚至可以使用AEM外部的Web應用程式防火牆，使用一組靜態的篩選器，而不需要深入瞭解底層AEM系統來保護您的系統：

```
Allow: /content/dam/(-\_/a-z0-9)+/(-\_a-z0-9)+
       \.respi\.q-(20|40|60|80|100)\.jpg
```

如果您沒有Web應用程式防火牆，則必須在Dispatcher或AEM中篩選。 如果您在AEM中執行此動作，請確定

1. 此篩選器的實作非常有效率，不會存取CRX太多且浪費記憶體和時間。

2. 篩選器會回應「404 — 找不到」錯誤訊息

讓我們再次強調最後一個點。 HTTP交談看起來像這樣：

```plain
  GET /content/dam/flower.respi.q-41.jpg

  Response: 404 – Not found
  << empty response body >>
```

我們也見過實作，雖然篩選了無效引數，但在使用無效引數時傳回有效的遞補演算。 假設我們僅允許20-100之間的引數。 介於之間的值會對應至有效的值。 所以，

`q-41, q-42, q-43, …`

會一律回應與q-40相同的影像：

```plain
  GET /content/dam/flower.respi.q-41.jpg

  Response: 200 – OK
  << flower.jpg with quality = 40 >>
```

這種做法完全沒有幫助。 這些要求實際上是有效的要求。  它們會耗用處理能力，並佔用Dispatcher上快取目錄中的空間。

最好是傳回 `301 – Moved permanently`：

```plain
  GET /content/dam/flower.respi.q-41.jpg

  Response: 301 – Moved permanently
  Location: /content/dam/flower.respi.q-40.jpg
```

AEM會在此處告知瀏覽器。 「我沒有 `q-41`. 但是您好，您可以問我 `q-40` 「。

這會在交談中新增額外的要求 — 回應回圈，雖然有點額外負荷，但比完全處理要便宜 `q-41`. 而且您可以利用已快取的檔案 `q-40`. 不過您必須瞭解，Dispatcher中未快取302個回應，我們所討論的邏輯是在AEM中執行。 一遍又一遍。 因此您最好讓電腦更輕薄、更快速。

我們個人喜歡404回應最多。 如此一來，事情就變得非常明顯。 並協助在您分析記錄檔時偵測網站上的錯誤。 301s是有意為之，應一律分析並刪除404。

## 安全性 — 離位

### 篩選請求

#### 何處篩選最佳專案

在最後一章的結尾，我們指出必須篩選已知選取器的傳入流量。 於是問題來了：我實際上應該從哪裡篩選請求？

嗯 — 視情況而定。 越快越好。

#### Web應用程式防火牆

如果您有專為Web Security設計的Web Application Firewall裝置或「WAF」，您絕對應該利用這些功能。 但您可能會發現，WAF是由對您的內容應用程式只有有限知識的人所操作，他們或是篩選有效請求，或是讓傳遞過多有害請求。 您可能會發現操作WAF的人員被指派到具有不同班次和發行排程的不同部門，溝通可能不像與直接隊友一樣緊密，而且您並不總是能及時得到變更，這意味著最終您的開發和內容速度會受到影響。

您最後可能會遇到一些一般規則，甚至可能是封鎖清單，而您的直覺告訴我，這些規則可能會更嚴格。

#### Dispatcher和發佈篩選

下一步是在Apache核心和/或Dispatcher中新增URL篩選規則。

您在這裡只能存取URL。 僅限使用圖樣型篩選器。 如果您需要設定更多以內容為基礎的篩選（例如只允許具有正確時間戳記的檔案），或您想要在作者上控制一些篩選，您最終可能會撰寫類似自訂servlet篩選器的內容。

#### 監視和偵錯

實際操作中，您會在每個層級上擁有一些安全性。 但請確定您有辦法找出在哪個層級篩選出了請求。 確保您可以直接存取發佈系統、Dispatcher和WAF上的記錄檔，以找出鏈結中的哪個篩選器正在封鎖請求。

### 選擇器和選擇器數量激增

在上一章中使用「選取器 — 引數」的方法既快速又簡單，可以加快新元件的開發時間，但也有侷限性。

設定「quality」屬性只是一個簡單的範例。 但假設servlet也希望「寬度」的引數能更通用。

您可以減少可能的選取器值數目，以減少有效URL的數目。 您也可以對寬度執行相同操作：

品質= q-20、q-40、q-60、q-80、q-100

寬度= w-100、w-200、w-400、w-800、w-1000、w-1200

但現在所有組合都是有效的URL：

```
/content/dam/flower.respi.q-40.w-200.jpg
/content/dam/flower.respi.q-60.w-400.jpg
…
```

現在，我們已經有一個資源的5x6=30個有效URL。 每個額外的屬性都會增加複雜性。 而且可能會有屬性，這些屬性無法縮減為合理數量的值。

因此，這種方法也有侷限性。

#### 不慎公開API

這裡有什麼變化？ 如果我們仔細觀察，就會發現，我們正逐漸從靜態轉譯成為高度動態的網站。 而且我們無意中將影像轉譯API提供給客戶的瀏覽器，而實際上該API僅供作者使用。

設定影像的品質和大小應由編輯頁面的作者完成。 如果servlet公開相同的功能，就可能被視為拒絕服務攻擊的一種功能或向量。 實際內容取決於內容。 網站的業務關鍵程度如何？ 伺服器上有多少負載？ 還剩下多少空間？ 您對實作有多少預算？ 您必須平衡這些因素。 您應該注意優缺點。

## 多工緩衝處理器模式 — 重新檢視並修復

### 多工緩衝處理器如何避免公開API

我們在最後一章中在一定程度上降低了多工緩衝處理程式模式的信用。 是時候修復它了。

![](assets/chapter-1/spooler-pattern.png)

多工緩衝處理器模式可防止公開我們在上一章中討論的API時出現的問題。 屬性會儲存並封裝在元件中。 我們只需要存取元件的路徑即可存取這些屬性。 我們不必使用URL作為工具，在標籤和二進位轉譯器之間傳輸引數：

1. 當主要請求回圈中請求元件時，使用者端會呈現HTML標籤

2. 元件路徑可作為從標籤到元件的回參照

3. 瀏覽器使用此反向參照來要求二進位

4. 當請求擊中元件時，我們手上擁有所有屬性，可調整二進位資料的大小、壓縮及多工緩衝處理

5. 影像會透過元件傳輸至使用者端瀏覽器

多工緩衝處理器模式畢竟沒有那麼糟糕，所以才如此受歡迎。 如果快取失效不是很麻煩……

### 反轉多工緩衝處理器 — 兩個領域的最佳選擇？

這引出了我們的問題。 為什麼我們不能兼得兩個世界的優點？ 多工緩衝處理器模式的良好封裝與資源型URL的良好快取屬性？

我們必須承認，我們尚未在實際的即時專案中看到這種情況。 但無論如何，讓我們在這裡做一個小小的思想實驗 — 作為您自己的解決方案的起點。

我們將此模式稱為 _反轉多工緩衝處理器_.. Inverted Spooler必須以影像資源為基礎，才能擁有所有良好的快取失效屬性。

但是不得公開任何引數。 所有屬性都應封裝在元件中。 但我們可以公開元件路徑 — 作為屬性的不透明參照。

這會導向表單中的URL：

`/content/dam/flower.respi3.content-mysite-home-jcrcontent-par-respi.jpg`

`/content/dam/flower` 是影像資源的路徑

`.respi3` 是選取正確servlet以傳送影像的選擇器

`.content-mysite-home-jcrcontent-par-respi` 是額外的選擇器。 它會編碼儲存影像轉換所需屬性的元件的路徑。 選取器限製為比路徑小的字元範圍。 這裡的編碼配置只是範例。 會以「 — 」取代「/」。 並未考慮路徑本身也能包含「 — 」。 在真實世界的範例中，建議使用更複雜的編碼配置。 Base64應該正常。 但這會讓偵錯變得更加困難。

`.jpg` 是檔案字尾

### 結論

哇……多工緩衝處理器的討論比預期的更長更複雜。 我們缺你個藉口。 但我們覺得有必要向您呈現許多方面 — 好與壞 — 以便您可以對於哪些在Dispatcher區域良好運作以及哪些不良好產生一些直覺。

## Statfile和Statfile層級

### 基本知識

#### 簡介

我們已簡短地提過 _statfile_ 之前。 它與自動失效有關：

如果Dispatcher檔案系統中所有設定為自動失效的快取檔案的上次修改日期早於 `statfile's` 上次修改日期。

>[!NOTE]
>
>我們討論的上次修改日期是快取檔案，是從使用者端瀏覽器請求該檔案，並最終在檔案系統中建立的日期。 它不是 `jcr:lastModified` 資源的日期。

statfile的上次修改日期(`.stat`)是在Dispatcher上收到來自AEM的失效請求的日期。

如果您有多個Dispatcher，這可能會導致奇怪的效果。 您的瀏覽器可以有較新版本的Dispatcher （如果您有一個以上的Dispatcher）。 或者Dispatcher可能認為其他Dispatcher所發行的瀏覽器版本已過時，且會不必要地傳送新復本。 這些效果對效能或功能需求沒有重大影響。 而且當瀏覽器有最新版本時，這些量度會隨著時間逐漸平準。 不過，當您最佳化和偵錯瀏覽器快取行為時，可能會有點令人困惑。 因此請務必注意。

#### 使用/statfileslevel設定失效網域

當我們推出自動失效功能時，我們曾說： *全部* 若有任何變更，且所有檔案皆相互依存，則會將檔案視為無效。

這並不十分準確。 通常，共用相同主要導覽根目錄的所有檔案都是相依的。 但一個AEM執行個體可以託管多個網站 —  *獨立* 網站。 未共用共用共用導覽 — 事實上，未共用任何內容。

讓網站B失效不是很浪費因為網站A有變動？ 是的，確實是。 而且不一定非要如此。

Dispatcher提供簡單的方式來分隔網站： `statfiles-level`.

這是一個數字，定義檔案系統中的哪個層級，將兩個子樹狀結構視為「獨立」。

讓我們看看statfileslevel為0的預設案例。

![/statfileslevel &quot;0&quot;：_ _.stat_ 在docroot中建立(_i)。 失效網域涵蓋整個安裝，包括所有網站](assets/chapter-1/statfile-level-0.png)

`/statfileslevel "0":` 此 `.stat` 檔案是在docroot中建立。 失效網域涵蓋整個安裝，包括所有網站。

無論哪個檔案失效， `.stat` dispatchers docroot最頂端的檔案一律會更新。 所以當您使無效 `/content/site-b/home`，也代表所有檔案 `/content/site-a` 也會失效，因為它們現在比 `.stat` 檔案。 當您使無效時，顯然不是您需要的內容 `site-b`.

在此範例中，您寧可設定 `statfileslevel` 至 `1`.

現在，如果您發佈 — 並因此失效 `/content/site-b/home` 或以下任何其他資源 `/content/site-b`，則 `.stat` 檔案建立於 `/content/site-b/`.

以下內容 `/content/site-a/` 不會受到影響。 此內容會與 `.stat` 檔案位於 `/content/site-a/`. 我們已建立兩個不同的失效網域。

![statfileslevel &quot;1&quot;會建立不同的失效網域](assets/chapter-1/statfiles-level-1.png)

*statfileslevel &quot;1&quot;會建立不同的失效網域*

<br> 

大型安裝通常在結構上更複雜、更深入。 常見的方案是依品牌、國家/地區和語言來建構網站。 在這種情況下，您可以將statfileslevel設定得更高。 _1_ 會根據品牌建立失效網域， _2_ 每個國家/地區和 _3_ 每種語言。

### 同質網站結構的必要性

statfileslevel會平均套用至您設定中的所有網站。 因此，所有網站都必須遵循相同的結構，且從相同的層級開始。

假設您的產品組合中有些品牌只在少數幾個小型市場銷售，而其他品牌則在全世界銷售。 小型市場剛好只有一種當地語言，而在全球市場上，有些國家講一種以上的語言：

```plain
  /content/tiny-local-brand/finland/home
  /content/tiny-local-brand/finland/products
  /content/tiny-local-brand/finland/about
                              ^
                          /statfileslevel "2"
  …

  /content/tiny-local-brand/norway
  …

  /content/shiny-global-brand/canada/en
  /content/shiny-global-brand/canada/fr
  /content/shiny-global-brand/switzerland/fr
  /content/shiny-global-brand/switzerland/de
  /content/shiny-global-brand/switzerland/it
                                          ^
                                /statfileslevel "3"
  ..
```

前者需要一個 `statfileslevel` 之 _2_，而後者需要 _3_.

不是理想的情況。 如果您將其設為 _3_，則自動失效無法在子分支之間的較小網站內運作 `/home`， `/products` 和 `/about`.

設定為 _2_ 表示在較大的網站中，您宣告的 `/canada/en` 和 `/canada/fr` 相依性，但可能不是。 因此，中的每一項失效 `/en` 也會使失效 `/fr`. 這會導致快取命中率稍微下降，但仍比傳送過時的快取內容更好。

當然，最好的解決方案是讓所有網站的根都一樣深：

```
/content/tiny-local-brand/finland/fi/home
/content/tiny-local-brand/finland/fi/products
/content/tiny-local-brand/finland/fi/about
…
/content/tiny-local-brand/norway/no/home
                                 ^
                        /statfileslevel "3"
```

### 網站間連結

哪一個層級正確？ 這取決於您在網站之間的相依性數量。 您解析來呈現頁面的包含專案會視為「硬相依性」。 我們展示了 _包含_ 當我們引入 _Teaser_ 本指南開頭的元件。

_超連結_ 是較軟的相依性形式。 您很有可能會在一個網站內建立超連結……而且您的網站之間也不太可能有連結。 簡單的超連結通常不會在網站之間建立相依性。 只要想一下您從網站設定為facebook的外部連結……如果facebook上有任何變更，您就不需要轉譯頁面，反之亦然，對嗎？

當您從連結的資源（例如導覽標題）讀取內容時，會發生相依性。 如果您只依賴本機輸入的導覽標題，而不從目標頁面繪製它們（如同使用外部連結一樣），則可避免此類相依性。

#### 非預期的相依性

不過，您的設定中可能有一部分（據信是獨立的）網站會整合在一起。 讓我們來看看我們在其中一個專案中遇到的真實案例。

客戶的網站結構與上一章中草繪的網站結構類似：

```
/content/brand/country/language
```

例如，

```
/content/shiny-brand/switzerland/fr
/content/shiny-brand/switzerland/de

/content/shiny-brand/france/fr

/content/shiny-brand/germany/de
```

每個國家/地區都有自己的網域，

```
www.shiny-brand.ch

www.shiny-brand.fr

www.shiny-brand.de
```

語言網站之間沒有可導覽的連結，也沒有明顯的包含專案，因此我們將statfileslevel設定為3。

所有網站基本上都提供相同的內容。 唯一的主要差異是語言。

Google等搜尋引擎會將相同的內容放在不同的URL上「欺騙」。 使用者可以嘗試透過建立提供相同內容的陣列來嘗試獲得更高的排名或更常被列出。 搜尋引擎會識別這些嘗試，並實際對僅能回收內容的頁面進行較低排名。

您可以透過透明化來避免排名下降，您事實上擁有多個相同內容的頁面，而且您並未嘗試「博弈」系統(請參閱 [「向Google說明頁面的本地化版本」](https://support.google.com/webmasters/answer/189077?hl=en))，方法是設定 `<link rel="alternate">` 標籤至每個頁面標頭區段中每個相關頁面：

```
# URL: www.shiny-brand.fr/fr/home/produits.html

<head>

  <link rel="alternate" 
        hreflang="fr-ch" 
        href="http://www.shiny-brand.ch/fr/home/produits.html">
  <link rel="alternate" 
        hreflang="de-ch" 
        href="http://www.shiny-brand.ch/de/home/produkte.html">
  <link rel="alternate" 
        hreflang="de-de" 
        href="http://www.shiny-brand.de/de/home/produkte.html">

</head>

----

# URL www.shiny-brand.de/de/home/produkte.html

<head>

  <link rel="alternate" 
        hreflang="fr-fr" 
        href="http://www.shiny-brand.fr/fr/home/produits.html">
  <link rel="alternate" 
        hreflang="fr-ch" 
        href="http://www.shiny-brand.ch/fr/home/produits.html">
  <link rel="alternate" 
        hreflang="de-ch"
         href="http://www.shiny-brand.ch/de/home/produits.html">

</head>
```

![全部相互連結](assets/chapter-1/inter-linking-all.png)

*全部相互連結*

<br> 

有些SEO專家甚至認為，這可能將一種語言的高階網站的信譽或「連結汁」轉移到另一種語言的相同網站。

此配置不僅造成許多連結，也造成一些問題。 所需的連結數 _p_ 在 _n_ 語言是 _p x (n<sup>2</sup>-n)_：每個頁面連結至彼此頁面(_n x n_)，但本身除外(_-n_)。 此配置會套用至每個頁面。 如果我們的網站採用4種語言，每種20頁大小，則每個網頁都等於 _240_ 連結。

首先，您不希望編輯器必須手動維護這些連結 — 這些連結必須由系統自動產生。

第二，它們應該是準確的。 每當系統偵測到新的「相對」時，您就會想要從其他所有內容相同（但使用不同語言）的頁面將其連結。

在我們的專案中，經常會彈出新的相對頁面。 但是這些連結並未實作為「替代」連結。 例如，當 `de-de/produkte` 此頁面已發佈至德國網站，無法立即顯示於其他網站。

原因在於，在我們的設定中，網站應該是獨立的。 因此，德國網站上的變更並未觸發法國網站上的失效。

您已知道如何解決這個問題。 只需將statfileslevel降低為2即可擴大失效網域。 當然，這也會降低快取命中率（尤其是在發佈時），因此失效的頻率會更高。

在我們的案例中，情況甚至更複雜：

雖然我們擁有相同的內容，但每個國家/地區的實際非品牌名稱不同。

`shiny-brand` 已呼叫 `marque-brillant` 法國和 `blitzmarke` 在德國：

```
/content/marque-brillant/france/fr
/content/shiny-brand/switzerland/fr
/content/shiny-brand/switzerland/de
/content/blitzmarke/germany/de
…
```

這表示設定 `statfiles` 層級為1 — 這會導致過大的失效網域。

重新建構網站便可修正此問題。 將所有品牌合併到一個共同根下。 但是我們當時沒有容量，那只能提供我們第2級。

我們決定堅持使用第3級，並支付不總是擁有最新「替代」連結的代價。 為了減輕影響，我們在Dispatcher上執行了一個「reaper」cron-job，該作業無論如何都會清除超過1週的檔案。 所以最終所有頁面都會在某個時間點重新呈現。 但這是需要分別在每個專案中決定的權衡。

## 結論

我們介紹了Dispatcher一般運作方式的一些基本原則，並舉例說明您可能必須投入更多實施工作才能正確運作以及您可能想要權衡取捨之處。

我們並未深入瞭解如何在Dispatcher中設定此專案的詳細資訊。 我們希望您能先瞭解基本概念和問題，避免過早迷失於主控台。 此外，實際的設定工作已有完整記錄 — 如果您瞭解基本概念，您應該知道各種交換器的用途。

## Dispatcher提示與秘訣

在本書的第一部分中，我們將隨機收集一些可能適合各種情況的提示和技巧。 如同先前一樣，我們並非在展示解決方案，而是介紹這個構想，讓您有機會瞭解這個構想和概念，並連結到更詳細地描述實際設定的文章。

### 修正失效時間

如果您直接安裝AEM Author和Publish，拓撲會有點奇怪。 作者會將內容傳送至發佈系統，同時將失效請求傳送至Dispatcher。 由於發佈系統和Dispatcher兩者都是透過佇列與作者脫鉤，計時可能會有點不幸。 在發佈系統上更新內容之前，Dispatcher可以接收來自作者的失效請求。

如果使用者端同時請求該內容，Dispatcher將會請求並儲存過時內容。

更可靠的設定是從Publish系統傳送失效請求 _晚於_ 他們已收到內容。 文章»[使發佈執行個體中的Dispatcher快取失效](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html#InvalidatingDispatcherCachefromaPublishingInstance)」說明詳細資訊。

**引用**

[helpx.adobe.com — 使發佈執行個體中的Dispatcher快取失效](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html#InvalidatingDispatcherCachefromaPublishingInstance)

### HTTP標頭與標頭快取

過去，Dispatcher只會將純檔案儲存在檔案系統中。 如果您需要將HTTP標頭傳送給客戶，您可以根據檔案或位置中的少量資訊來設定Apache，以執行此操作。 當您在AEM中實作高度依賴HTTP標題的網頁應用程式時，這尤其令人煩惱。 在僅限AEM的執行個體中，一切都能正常運作，但在您使用Dispatcher時卻無法正常運作。

通常，您會開始使用以下專案將缺少的標頭重新套用至Apache伺服器中的資源 `mod_headers` 使用可由資源路徑與字尾衍生的資訊。 但這並不總是足夠的。

尤其令人討厭的是，即使使用Dispatcher _未快取_ 瀏覽器的回應來自具有完整標題範圍的Publish系統，而後續回應是由Dispatcher使用有限的標題集產生的。

從Dispatcher 4.1.11開始，Dispatcher可以儲存發佈系統產生的標頭。

這可協助您避免在Dispatcher中重複標題邏輯，並釋放HTTP和AEM的完整表達能力。

**引用**

* [helpx.adobe.com — 快取回應標頭](https://helpx.adobe.com/experience-manager/kb/dispatcher-cache-response-headers.html)

### 個別快取例外狀況

一般而言，您可能想要快取所有頁面和影像，但在某些情況下會列為例外。 例如，您要快取PNG影像，但不快取PNG影像以顯示驗證碼（假設會在每個請求上變更）。 Dispatcher可能不會將驗證碼識別為驗證碼……但AEM當然會識別。 它可以要求Dispatcher不要透過傳送相應的標頭以及回應來快取該請求：

```plain
  response.setHeader("Dispatcher", "no-cache");

  response.setHeader("Cache-Control: no-cache");

  response.setHeader("Cache-Control: private");

  response.setHeader("Pragma: no-cache");
```

Cache-Control和Pragma是正式的HTTP標頭，會傳播到上層快取層（例如CDN）並由其解釋。 此 `Dispatcher` 標頭只是Dispatcher不要快取的提示。 它可用來告知Dispatcher不要快取，同時仍允許上層快取圖層這麼做。 實際上，很難找到可能有用的案例。 但我們肯定有某些地方存在。

**引用**

* [Dispatcher — 無快取](https://helpx.adobe.com/experience-manager/kb/DispatcherNoCache.html)

### 瀏覽器快取

最快的http回應是瀏覽器本身提供的回應。 其中請求和回應不需要在高負載下透過網路傳送到網頁伺服器。

您可以設定資源的到期日，以協助瀏覽器決定何時向伺服器要求檔案的新版本。

通常，您可以使用Apache的 `mod_expires` 或儲存來自AEM的Cache-Control和Expires Header （如果您需要更個別的控制項）。

瀏覽器中的快取檔案可以具有三個最新層級。

1. _保鮮_  — 瀏覽器可以使用快取的檔案。

2. _可能過時_  — 瀏覽器應先詢問伺服器快取的檔案是否仍為最新狀態，

3. _過時_  — 瀏覽器必須要求伺服器提供新版本。

第一個是由伺服器設定的到期日保證。 如果資源未過期，就不需要再次詢問伺服器。

如果檔案到達到期日，它仍可以是新的。 到期日會在檔案送達時設定。 但您經常不知道何時有新內容可用 — 因此這只是保守的估計。

若要確定瀏覽器快取中的檔案是否仍會與新請求時傳送的檔案相同，瀏覽器可使用 `Last-Modified` 檔案日期。 瀏覽器會詢問伺服器：

&quot;_我有從6月10日起的版本……我需要更新嗎？_」而伺服器可能會回應

&quot;_304 — 您的版本仍是最新版本_&quot;而不重新傳輸資源，或伺服器可透過回應

&quot;_200 — 以下是較新的版本_ HTTP標題中的&quot;，以及HTTP內文中的實際較新內容。

若要讓第二個部分正常運作，請務必傳輸 `Last-Modified` 瀏覽器的日期，以便有參考點可要求更新。

我們先前解釋過，當 `Last-Modified` 日期是由Dispatcher產生的，它可能因不同請求而異，因為快取檔案（及其日期）是在瀏覽器請求檔案時產生的。 另一種選擇是使用「e-tags」 — 這些數字可識別實際內容（例如，透過產生雜湊代碼）而不是日期。

&quot;[Etag支援](https://adobe-consulting-services.github.io/acs-aem-commons/features/etag/index.html)」來自 _ACS Commons套件_ 會使用此方法。 但這也有代價：由於E-Tag必須以標頭形式傳送，但雜湊程式碼的計算需要完全讀取回應，因此回應必須在主要記憶體中完全緩衝，才能傳送。 如果您的網站很可能有未快取的資源，而且您當然需要留意AEM系統消耗的記憶體，這可能會對延遲產生負面影響。

如果您使用URL指紋，則可以設定很長的到期日。 您可以在瀏覽器中永遠快取指紋資源。 新版本會標籤新的URL，舊版本則永遠不需要更新。

我們在引入多工緩衝處理器模式時，使用了URL指紋。 來自的靜態檔案 `/etc/design` (CSS、JS)很少變更，這也使其成為用作指紋的良好候選專案。

對於一般檔案，我們通常會設定固定的配置，例如每30分鐘重新檢查HTML、每4小時檢查一次影像等。

瀏覽器快取在Author系統上非常有用。 您想要在瀏覽器中快取儘可能多的內容，以增強編輯體驗。 很抱歉，最昂貴的資產html頁面無法快取……作者應經常變更這些頁面。

構成AEM UI的Granite程式庫可以快取相當長的時間。 您也可以在瀏覽器中快取網站靜態檔案（字型、CSS和JavaScript）。 中的偶數影像 `/content/dam` 通常可以快取約15分鐘，因為它們不會像頁面上的複製文字那樣經常變更。 影像不會在AEM中以互動方式編輯。 這些檔案會先經過編輯和核准，再上傳至AEM。 因此，您可以假設它們沒有像文字那樣頻繁地變更。

當您處於編輯模式時，快取UI檔案、您的網站程式庫檔案和影像可大幅加快頁面重新載入的速度。



**引用**

*[developer.mozilla.org — 快取](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)

* [apache.org - Mod過期](https://httpd.apache.org/docs/current/mod/mod_expires.html)

* [ACS Commons - Etag支援](https://adobe-consulting-services.github.io/acs-aem-commons/features/etag/index.html)

### 正在截斷URL

您的資源會儲存在

`/content/brand/country/language/…`

但當然，這不是您想向客戶顯示的URL。 基於美學、可讀性和SEO等理由，您可能想要截斷已在網域名稱中表示的零件。

如果您有網域

`www.shiny-brand.fi`

通常不需要讓品牌和國家走上正軌。 而非

`www.shiny-brand.fi/content/shiny-brand/finland/fi/home.html`

您想要，

`www.shiny-brand.fi/home.html`

您必須在AEM上實作該對應，因為AEM需要知道如何根據該截斷格式演算連結。

但請勿僅依賴AEM。 如果這樣做，您會有類似以下的路徑 `/home.html` 在快取的根目錄中。 現在，這是Finish的「首頁」、德文版還是加拿大版？ 如果有檔案 `/home.html` 在Dispatcher中，Dispatcher如何知道當的失效請求時，這必須失效 `/content/brand/fi/fi/home` 進來。

我們已經看到一個專案，每個網域都有不同的docroots。 進行除錯和維護真是噩夢 — 實際上，我們從未看到它完美運作。

我們可以藉由重新建構快取來解決問題。 所有網域都有單一docroot，當伺服器上的所有檔案開始使用時，失效請求可以以1:1處理 `/content`.

截斷部分也非常簡單。  AEM因為中的設定而產生了截斷的連結 `/etc/map`.

現在當有請求時 `/home.html` 點選Dispatcher，首先發生的是套用可在內部擴展路徑的重寫規則。

該規則是在每個vhost設定中以靜態方式設定。 簡言之，規則看起來像這樣，

```plain
  # vhost www.shiny-brand.fi

  RewriteRule "^(.\*\.html)" "/content/shiny-brand/finland/fi/$1"
```

在檔案系統中，我們現在有了 `/content` — 型路徑，可在Author和Publish上找到 — 這有助於進行大量偵錯。 更不用說正確失效 — 這不再是個問題。

請注意，我們僅針對「可見」URL這麼做，這些URL會顯示在瀏覽器的URL位置中。 例如影像的URL仍為純「/content」URL。 我們認為，就搜尋引擎最佳化而言，美化「主要」URL已足夠。

擁有一個通用的docroot也有另一個不錯的功能。 當Dispatcher中發生任何錯誤時，我們可以通過執行來清除整個快取，

`rm -rf /cache/dispatcher/*`

（某些您可能不想在高負載尖峰時執行的動作）。

**引用**

* [apache.org — 修改重新寫入](https://httpd.apache.org/docs/2.4/mod/mod_rewrite.html)

* [helpx.adobe.com — 資源對應](https://helpx.adobe.com/experience-manager/6-4/sites/deploying/using/resource-mapping.html)

### 錯誤處理

在AEM課程中，您可以瞭解如何在Sling中設定錯誤處理常式。 這與撰寫一般範本並無太大不同。 您只要用JSP或HTL撰寫範本即可，對嗎？

是 — 但這只是AEM部分。 記住 — Dispatcher不會快取 `404 – not found` 或 `500 – internal server error` 回應。

如果您在每個（失敗的）請求上動態呈現這些頁面，Publish系統上將會有不必要的高負載。

我們發現有用的是在發生錯誤時不呈現完整的錯誤頁面，而只呈現超簡化和小型頁面，甚至是靜態版本的頁面，沒有任何裝飾或邏輯。

這當然不是客戶所看到的。 在Dispatcher中，我們註冊了 `ErrorDocuments` 如下所示：

```
ErrorDocument 404 "/content/shiny-brand/fi/fi/edocs/error-404.html"
ErrorDocument 500 "/content/shiny-brand/fi/fi/edocs/error-500.html"
```

現在，AEM系統只需通知Dispatcher發生錯誤，Dispatcher就可以傳送醒目且精美的錯誤檔案版本。

請注意兩件事。

首先， `error-404.html` 永遠是同一個頁面。 因此，沒有像「您的搜尋」這樣的個別訊息&#x200B;_produkten_「未產生結果」。 我們可以輕鬆地接受這一點。

第二……嗯，如果我們看到內部伺服器錯誤 — 甚至更糟的是，我們遇到AEM系統中斷，就沒有辦法要求AEM呈現錯誤頁面，對吧？ 中定義的必要後續請求 `ErrorDocument` 指示詞也會失敗。 我們透過執行cron-job來解決此問題，它會定期透過從定義的位置提取錯誤頁面 `wget` 並將其儲存至中定義的靜態檔案位置 `ErrorDocuments` 指令。

**引用**

* [apache.org — 自訂錯誤檔案](https://httpd.apache.org/docs/2.4/custom-error.html)

### 快取受保護內容

Dispatcher在預設情況下傳送資源時不會檢查許可權。 實作方式與以下類似，是有意為之 — 以加速您的公用網站。 如果您想透過登入來保護某些資源，您基本上有三個選項：

1. 在請求點選快取之前Protect資源 — 即由Dispatcher前面的SSO （單一登入）閘道進行，或當作Apache伺服器中的模組

2. 排除敏感資源不進行快取，因此一律會從Publish系統即時提供這些資源。

3. 在Dispatcher中使用許可權敏感型快取

當然，您可以套用您自己的所有三種方法組合。

**選項1**. 貴組織仍可強制執行「SSO」閘道。 如果您的存取配置非常粗糙，您可能不需要來自AEM的資訊來決定是否授與或拒絕對資源的存取權。

>[!NOTE]
>
>此模式需要 _閘道_ 該 _截獲_ 每個請求並執行實際 _授權_  — 核准或拒絕對Dispatcher的請求。 如果您的SSO系統是 _驗證者_，只會建立您必須實作選項3之使用者的身分識別。 如果您在SSO系統手冊中閱讀「SAML」或「OAauth」等詞語，這是您必須實施選項3的有力指標。


**選項2**. 「不快取」通常不是個好主意。 如果您這麼做，請確定排除的流量和敏感資源數量都很少。 或者，請確定在Publish系統中安裝了一些記憶體中的快取，讓Publish系統能夠處理產生的負載 — 此系列的第III部分將對此進行詳細介紹。

**選項3**. 「許可權敏感型快取」是一種有趣的方法。 Dispatcher正在快取資源，但在傳送資源之前，會詢問AEM系統是否可這麼做。 這會從Dispatcher建立額外的請求給Publish — 但通常可避免Publish系統重新呈現已快取的頁面。 不過，此方法需要一些自訂實施。 在此文章中尋找詳細資訊 [許可權敏感型快取](https://helpx.adobe.com/experience-manager/dispatcher/using/permissions-cache.html).

**引用**

* [helpx.adobe.com — 許可權敏感型快取](https://helpx.adobe.com/experience-manager/dispatcher/using/permissions-cache.html)

### 設定寬限期

如果您經常在短時間內讓內容失效（例如因為樹狀結構啟動或只是為了保持內容最新狀態），您可能會經常排清快取，而訪客幾乎總是點選空白快取。

下圖說明存取單一頁面時的可能時間。  當然，當請求的不同頁面數量增加時，問題會變得更嚴重。

![經常啟用導致大部分時間快取無效](assets/chapter-1/frequent-activations.png)

*經常啟用導致大部分時間快取無效*

<br> 

為了緩解有時所說的「快取失效風暴」問題，您可以對 `statfile` 解釋。

您可以設定Dispatcher使用 `grace period` 以自動失效。 這會在內部增加一些額外時間至 `statfiles` 修改日期。

比方說， `statfile` 修改時間為今天12:00，且 `gracePeriod` 設為2分鐘。 然後，所有自動失效的檔案在12:01和12:02被視為有效。 它們會在12:02後重新呈現。

參考設定會建議 `gracePeriod` 2分鐘內，原因很清楚。 您可能會想「兩分鐘？ 這幾乎什麼都不是。 我可以輕鬆等待10分鐘讓內容顯示……」。  因此，您可能會想要設定更長的時段（假設10分鐘），假設您的內容至少在這個10分鐘後顯示。

>[!WARNING]
>
>這不是方法 `gracePeriod` 運作中。 寬限期為 _not_ 保證檔案失效，但不會發生失效的時間範圍。 屬於此框架的每個後續失效 _延長時間_ 時間範圍 — 無限長。

讓我們說明如何 `gracePeriod` 實際使用的範例：

假設您經營的是媒體網站，而您的編輯人員每5分鐘會定期提供內容更新。 假設您將gracePeriod設為5分鐘。

我們在12:00會從快速範例開始。

12:00 - Statfile設定為12:00。 在12:05之前，所有快取檔案都視為有效。

12:01 — 發生失效。 如此將爐排時間延長至12:06

12:05 — 另一位編輯發表了他的文章 — 將寬限期延長另一個gracePeriod至12:10。

等等……內容永遠不會失效。 每次失效 *範圍* gracePeriod會有效延長寬限期。 此 `gracePeriod` 專門設計來抵禦失效風暴……但您最終必須外出下雨……所以，請保持 `gracePeriod` 相當短，可避免永遠躲在避難所裡。

#### 決定性的寬限期

我們想要介紹另一個想法，告訴您如何經受無效風暴。 這只是一個想法。 我們尚未在生產環境中嘗試，但我們發現這個概念相當有趣，足以與您分享這個想法。

此 `gracePeriod` 如果您的定期復寫間隔短於 `gracePeriod`.

替代想法如下：僅在固定時間間隔內失效。 兩者之間的時間長度一律代表提供過時內容。 最終將會發生失效，但一旦「大量」失效，則會收集到許多失效資料，這樣Dispatcher就有機會同時提供一些快取的內容，並讓Publish系統喘不過氣來。

實作將如下所示：

您使用「自訂失效指令碼」（請參閱參考），該指令碼將在失效發生後執行。 此指令碼會讀取 `statfile's` 上次修改日期，並將其四捨五入至下一個間隔停止。 Unix shell指令 `touch --time`，讓您指定時間。

例如，如果您將寬限期設為30秒，Dispatcher會將statfile的上次修改日期舍入到接下來的30秒。 在中發生的失效請求，只是設定相同的下一個完整30秒。

![將失效延遲到下一個完整的30秒會增加點選率。](assets/chapter-1/postponing-the-invalidation.png)

*將失效延遲到下一個完整的30秒會增加點選率。*

<br> 

接著，在失效請求和下一個回合30秒槽之間發生的快取點選會被視為過時；發佈時已更新 — 但Dispatcher仍會提供舊內容。

此方法有助於定義較長的寬限期，而不用擔心後續請求會無限期地延長寬限期。 雖然如我們先前所述 — 這只是一個構想，我們尚無法進行測試。

**引用**

[helpx.adobe.com - Dispatcher設定](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html)

### 自動重新擷取

您的網站具有非常特殊的存取模式。 您的傳入流量負載高，且大部分流量都集中在您的一小部分頁面上。 首頁、行銷活動登陸頁面和最精選的產品詳細資料頁面會收到90%的流量。 或者，如果您經營新網站，較新的文章的流量會比較舊的文章高。

現在，由於請求頻率很高，這些頁面很可能會在Dispatcher中快取。

任意的失效請求會傳送到Dispatcher，導致所有頁面（包括您最受歡迎一次）失效。

隨後，由於這些頁面如此受歡迎，因此會有來自不同瀏覽器的新傳入請求。 以首頁為例。

由於快取現在無效，所有同時傳入的首頁請求都會轉送至產生高負載的發佈系統。

![對空快取上的相同資源提出平行請求：將請求轉送至發佈](assets/chapter-1/parallel-requests.png)

*對空快取上的相同資源提出平行請求：將請求轉送至發佈*

使用自動重新擷取，您可在某種程度上緩解此問題。 在自動失效後，大多數失效的頁面仍會實際儲存在Dispatcher上。 它們只是 _已考慮_ 過時。 _自動重新擷取_ 這表示您仍在起始時提供這些過時頁面幾秒鐘 _單一_ 要求發佈系統重新擷取過時內容：

![在背景中重新擷取時提供過時內容](assets/chapter-1/fetching-background.png)

*在背景中重新擷取時提供過時內容*

<br> 

若要啟用重新擷取，您必須告訴Dispatcher在自動失效後要重新擷取哪些資源。 請記住，您啟用的任何頁面也會自動讓所有其他頁面失效，包括您常用的頁面。

重新擷取實際上代表通知每個(！)中的Dispatcher 失效請求中，您想要重新擷取最熱門的請求，以及最熱門的請求。

這是透過將資源URL （實際URL — 不僅僅是路徑）清單放入失效請求內文中來實現的：

```
POST /dispatcher/invalidate.cache HTTP/1.1

CQ-Action: Activate
CQ-Handle: /content/my-brand/home/path/to/some/resource
Content-Type: Text/Plain
Content-Length: 207

/content/my-brand/home.html
/content/my-brand/campaigns/landing-page-1.html
/content/my-brand/campaigns/landing-page-2.html
/content/my-brand/products/product-1.html
/content/my-brand/products/product-2.html
```

當Dispatcher看到這類請求時，就會像往常一樣觸發自動失效，並立即將請求排入佇列，以從發佈系統重新擷取最新內容。

由於我們現在是使用要求內文，因此也需要根據HTTP標準設定content-type和content-length。

Dispatcher也會在內部標籤相應的URL，這樣即使這些資源被自動失效視為無效，Dispatcher也可以直接傳送這些資源。

所有列出的URL都是逐一要求。 因此，您無需擔心在發佈系統上造成太高的負載。 但您也不想在該清單中放入太多URL。 最後，佇列最終需要在限定時間內處理，才能長時間提供過時內容。 只要包含您最常存取的10個頁面即可。

如果您檢視Dispatcher的快取目錄，您會看到標示有時間戳記的暫存檔。 這些是目前在背景中載入的檔案。

**引用**

[helpx.adobe.com — 使AEM中的快取頁面失效](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html)

### 保護發佈系統

Dispatcher會遮蔽Publish系統，使其免受僅用於維護目的的請求的影響，提供一些額外的安全性。 例如，您不想公開 `/crx/de` 或 `/system/console` 公開的URL。

在系統中安裝Web應用程式防火牆(WAF)並無害處。 但這會大幅增加您的預算，而且並非所有專案都能夠負擔得起，並且（不要忘記）操作和維護WAF。

我們經常看到Dispatcher設定中的一組Apache重寫規則，可防止存取較易受攻擊的資源。

但您也可以考慮另一種方法：

根據Dispatcher設定，Dispatcher模組會繫結到特定目錄：

```
<Directory />
  SetHandler dispatcher-handler
  …
</Directory>
```

但為何要在之後需要向下篩選時，將處理常式繫結至整個docroot？

首先，您可以縮小處理常式的繫結。 `SetHandler` 只要將處理常式繫結到目錄，您就可以將處理常式繫結到URL或URL模式：

```
<LocationMatch "^(/content|/etc/design|/dispatcher/invalidate.cache)/.\*">
  SetHandler dispatcher-handler
</LocationMatch>

<LocationMatch "^/dispatcher/invalidate.cache">
  SetHandler dispatcher-handler
</LocationMatch>

…
```

如果您這麼做，別忘了一律將Dispatcher處理常式繫結到Dispatcher的失效URL — 否則您將無法從AEM傳送失效請求到Dispatcher。

使用Dispatcher作為篩選器的另一個替代方法是在 `dispatcher.any`

```
/filter {
  /0001  { /glob "\*" /type "deny" }
  /0002  { /type "allow"  /url "/content\*"  }
```

我們並未強制使用其中一個指示詞，而是建議所有指示詞適當地混合。

但我們確實建議您儘可能及早在鏈結中縮小URL空間，視需要而定，並以最簡單的方式進行。 請記住，這些技術並不能取代高度敏感網站上的WAF。 有些人稱這些技術為「窮人的防火牆」 — 這是有原因的。

**引用**

[apache.org- sethandler指令](https://httpd.apache.org/docs/2.4/mod/core.html#sethandler)

[helpx.adobe.com — 設定對內容篩選器的存取權](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html#ConfiguringAccesstoContentfilter)

### 使用規則運算式和Glob進行篩選

回到早期，您只能使用「glob」 — 在Dispatcher設定中定義篩選器的簡單預留位置。

幸運的是，在較新版本的Dispatcher中已經變更。 現在您也可以使用POSIX規則運算式，而且您可以存取要求的不同部分來定義篩選器。 對於剛開始使用Dispatcher的人來說，這會被認為是理所當然的。 但如果您習慣只使用地球，這有點令人驚訝，也很容易被忽視。 此外，glob和regexes的語法也非常類似。 我們來比較兩個相同用途的版本：

```
# Version A

/filter {
  /0001  { /glob "\*" /type "deny" }
  /0002  { /type "allow"  /url "/content\*"  }

# Version B

/filter {
  /0001  { /glob "\*" /type "deny" }
  /0002  { /type "allow"  /url '/content.\*'  }
```

您看到不同之處了嗎？

版本B使用單引號 `'` 標籤 _規則運算式模式_. 「任何字元」會使用來表示 `.*`.

_萬用字元模式_，相反請使用雙引號 `"` 而且您只能使用簡單的預留位置，例如 `*`.

如果您知道這些差異，就覺得微不足道，但若不然，您可以輕鬆地混搭各種引號，花一個陽光明媚的下午為設定除錯。 現在警告您。

「我認得 `'/url'` 在設定中……但那是什麼 `'/glob'` 在篩選條件中，您可能會問？

該指示詞代表整個請求字串，包括方法和路徑。 它可代表

`"GET /content/foo/bar.html HTTP/1.1"`

這是將比較您模式的字串。 初學者往往會忘記第一部分， `method` (GET、POST...)。 因此，模式

`/0002  { /glob "/content/\*" /type "allow" }`

一律會失敗，因為「/content」與「GET..」 請求的。

所以當您想要使用地球時，

`/0002  { /glob "GET /content/\*" /type "allow" }`

是正確的。

對於初始拒絕規則，例如

`/0001  { /glob "\*" /type "deny" }`

這沒關係。 但對於後續的允許而言，使用請求的個別部分會更好且更清楚、更有表現力，也更安全：

```
/method
/url
/path
/selector
/extension
/suffix
```

如下所示：

```
/005  {

  /type "allow"
  /method "GET"
  /extension '(css|gif|ico|js|png|swf|jpe?g)' }
```

請注意，您可以在規則上混合使用regex和glob運算式。

有關「行號」的最後一個字，例如 `/005` 在每個定義的前面，

他們一點意義都沒有！ 您可以為規則選擇任意的分母。 使用數字不需要費力去考慮配置，但請記住，順序很重要。

如果您有數百個規則，例如：

```
/001
/002
/003
…
/100
…
```

而您想要在/001和/002之間插入一個數字，後續的數字會發生什麼情況？ 您是否要增加其數量？ 您是否在數字之間插入？

```
/001
/001a
/002
/003
…
/100
…
```

或者，如果您變更為/003和/001重新排序，將會發生什麼情況？您將會變更其名稱及其身分，或者您

```
/003
/002
/001
…
/100
…
```

編號，雖然一開始看起來是一個簡單的選擇，但從長遠來看，會達到其限制。 老實說，選擇數字作為識別碼無論如何都不是好的程式設計風格。

我們想要建議不同的方法：您很可能不會為每個個別篩選規則提供有意義的識別碼。 但它們可能服務於更大的目的，因此可以根據該目的以某種方式分組。 例如，「基本設定」、「應用程式特定例外」、「全域例外」和「安全性」。

然後，您可以相應地命名規則並將其分組，並在檔案中提供設定的讀者（您親愛的同事）一些方向：

```plain
  # basic setup:

  /filter {

    # basic setup

    /basic_01  { /glob "\*"             /type "deny"  }
    /basic_02  { /glob "/content/\*"    /type "allow" }
    /basic_03  { /glob "/etc/design/\*" /type "allow" }

    /basic_04  { /extension '(json|xml)'  /type "deny"  }
    …


    # login

    /login_01 { /glob "/api/myapp/login/\*" /type "allow" }
    /login_02 { … }

    # global exceptions

    /global_01 { /method "POST" /url '.\*contact-form.html' }
```


最有可能的情況是，您將新規則新增至其中一個群組，或甚至可能建立新群組。 在這種情況下，要重新命名/重新編號的專案數量將限制在該群組中。

>[!WARNING]
>
>更複雜的設定會將篩選規則分割為多個檔案，這些檔案包含在 `dispatcher.any` 設定檔。 但是新檔案不會引入新的名稱空間。 因此，如果您有一個檔案中的規則「001」，另一個檔案中的規則「001」，您將會收到錯誤。 更有理由想出語意強大的名字。

**引用**

[helpx.adobe.com — 為glob屬性設計模式](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html#DesigningPatternsforglobProperties)

### 通訊協定規格

最後一個秘訣並非真的秘訣，但我們覺得還是值得與您分享。

AEM和Dispatcher在多數情況下都是現成可用。 因此，您將找不到有關失效通訊協定的完整Dispatcher通訊協定規格，以在上面建置您自己的應用程式。 此資訊是公開的，但分散在多種資源中。

我們嘗試在某種程度上填補這個空白。 以下是失效請求的外觀：

```
POST /dispatcher/invalidate.cache HTTP/1.1
CQ-Action: <action>
CQ-Handle: <path-pattern>
[CQ-Action-Scope]
[Content-Type: Text/Plain]
[Content-Length: <bytes in request body>]

<newline>

<refetch-url-1>
<refetch-url-2>

…

<refetch-url-n>
```

`POST /dispatcher/invalidate.cache HTTP/1.1`  — 第一行是Dispatcher控制項端點的URL，您可能不會變更它。

`CQ-Action: <action>`  — 應該發生什麼情況。 `<action>` 為：

* `Activate:` 刪除 `/path-pattern.*`
* `Deactive:` 刪除 `/path-pattern.*`
AND刪除 `/path-pattern/*`
* `Delete:`   刪除 `/path-pattern.*`
AND刪除 
`/path-pattern/*`
* `Test:`   傳回「確定」但不執行任何操作

`CQ-Handle: <path-pattern>`  — 要失效的內容資源路徑。 注意， `<path-pattern>` 實際上是「路徑」而非「模式」。

`CQ-Action-Scope: ResourceOnly`  — 選用：若此標頭已設定，則 `.stat` 未觸及檔案。

```
[Content-Type: Text/Plain]
[Content-Length: <bytes in request body>]
```

如果您定義自動重新擷取URL的清單，請設定這些標頭。 `<bytes in request body>` 是HTTP內文中的字元數

`<newline>`  — 如果您有要求內文，必須用空白列將其與標頭區隔。

```
<refetch-url-1>
<refetch-url-2>
…
<refetch-url-n>
```

列出您要在失效後立即重新擷取的URL。

## 其他資源

Dispatcher快取的相關概述和簡介： [https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher.html](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher.html)

含有所有指示詞的Dispatcher檔案說明： [https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html](https://helpx.adobe.com/experience-manager/dispatcher/using/dispatcher-configuration.html)

部分常見問題集： [https://helpx.adobe.com/experience-manager/using/dispatcher-faq.html](https://helpx.adobe.com/experience-manager/using/dispatcher-faq.html)

有關Dispatcher最佳化的網路研討會影片 — 強烈建議： [https://my.adobeconnect.com/p7th2gf8k43?proto=true](https://my.adobeconnect.com/p7th2gf8k43?proto=true)

在Potsdam 2018舉行的「未充分瞭解的內容失效能力」、「adaptTo()」會議簡報 [https://adapt.to/2018/en/schedule/the-underappreciated-power-of-content-invalidation.html](https://adapt.to/2018/en/schedule/the-underappreciated-power-of-content-invalidation.html)

使AEM中的快取頁面失效： [https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html](https://helpx.adobe.com/experience-manager/dispatcher/using/page-invalidate.html)

## 下一步

* [2 — 基礎架構模式](chapter-2.md)
